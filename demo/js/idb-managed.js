(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["IDBM"] = factory();
	else
		root["IDBM"] = factory();
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/js/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ({

/***/ "./build/db_wrapper.js":
/*!*****************************!*\
  !*** ./build/db_wrapper.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @file Wrap idb APIs for idb-managed\n */\nvar utils_1 = __webpack_require__(/*! ./lib/utils */ \"./build/lib/utils.js\");\nvar idb_1 = __webpack_require__(/*! ./lib/idb */ \"./build/lib/idb.js\");\nvar IDB_MANAGER_VERSION = 1;\nvar IDB_MANAGER_DB_NAME = 'IDB_MANAGER_DB';\nvar IDB_MANAGER_DB_TABLE_NAME = 'IDB_MANAGER_STORE';\nvar IDB_MANAGER_DB_TABLE_INDEX_NAME = 'dbName';\nvar UPDATETIME_KEYNAME = 'updateTime';\nvar EXPIRETIME_KEYNAME = 'expireTime';\nfunction indexRange2DBKey(indexRange) {\n    var onlyIndex = indexRange.onlyIndex, lowerIndex = indexRange.lowerIndex, upperIndex = indexRange.upperIndex, _a = indexRange.lowerExclusive, lowerExclusive = _a === void 0 ? false : _a, _b = indexRange.upperExclusive, upperExclusive = _b === void 0 ? false : _b;\n    if (onlyIndex !== undefined) {\n        return IDBKeyRange.only(onlyIndex);\n    }\n    else if (lowerIndex !== undefined && upperIndex !== undefined) {\n        return IDBKeyRange.bound(lowerIndex, upperIndex, lowerExclusive, upperExclusive);\n    }\n    else if (lowerIndex !== undefined) {\n        return IDBKeyRange.lowerBound(lowerIndex, lowerExclusive);\n    }\n    else {\n        return IDBKeyRange.upperBound(upperIndex, upperExclusive);\n    }\n}\nfunction itemWrapper(itemConfig) {\n    var _a;\n    var currentTime = Date.now();\n    return __assign(__assign({}, itemConfig.item), (_a = {}, _a[UPDATETIME_KEYNAME] = currentTime, _a[EXPIRETIME_KEYNAME] = itemConfig.itemDuration !== undefined\n        ? itemConfig.itemDuration + currentTime\n        : -1, _a));\n}\nfunction itemUnwrapper(item) {\n    if (!item) {\n        return null;\n    }\n    else if (item.expireTime > 0 && item.expireTime < Date.now()) {\n        return null;\n    }\n    else {\n        delete item.updateTime;\n        delete item.expireTime;\n        return item;\n    }\n}\nfunction registerDBInManager(dbInfo) {\n    return __awaiter(this, void 0, void 0, function () {\n        var dbManager, dbAlreadyInManager, addDBTrans, table, dbItem;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0: return [4 /*yield*/, openDBManager()];\n                case 1:\n                    dbManager = _a.sent();\n                    return [4 /*yield*/, getItemFromDB(dbManager, IDB_MANAGER_DB_TABLE_NAME, dbInfo.name)];\n                case 2:\n                    dbAlreadyInManager = (_a.sent());\n                    if (!(!dbAlreadyInManager || dbInfo.version > dbAlreadyInManager.version)) return [3 /*break*/, 4];\n                    addDBTrans = dbManager.transaction(IDB_MANAGER_DB_TABLE_NAME, 'readwrite');\n                    table = addDBTrans.objectStore(IDB_MANAGER_DB_TABLE_NAME);\n                    dbItem = {\n                        dbName: dbInfo.name,\n                        tableList: dbInfo.tableList,\n                        version: dbInfo.version\n                    };\n                    table.put(itemWrapper({\n                        item: dbItem,\n                        tableName: IDB_MANAGER_DB_TABLE_NAME\n                    }));\n                    return [4 /*yield*/, addDBTrans.complete];\n                case 3:\n                    _a.sent();\n                    dbManager.close();\n                    _a.label = 4;\n                case 4: return [2 /*return*/];\n            }\n        });\n    });\n}\nfunction unregisterDBInManager(dbName) {\n    return __awaiter(this, void 0, void 0, function () {\n        var dbManager, deleteTrans, table;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0: return [4 /*yield*/, openDBManager()];\n                case 1:\n                    dbManager = _a.sent();\n                    deleteTrans = dbManager.transaction(IDB_MANAGER_DB_TABLE_NAME, 'readwrite');\n                    table = deleteTrans.objectStore(IDB_MANAGER_DB_TABLE_NAME);\n                    table.delete(dbName);\n                    return [4 /*yield*/, deleteTrans.complete];\n                case 2:\n                    _a.sent();\n                    dbManager.close();\n                    return [2 /*return*/];\n            }\n        });\n    });\n}\nfunction createDB(dbInfo) {\n    return __awaiter(this, void 0, void 0, function () {\n        var db;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0: return [4 /*yield*/, registerDBInManager(dbInfo)];\n                case 1:\n                    _a.sent();\n                    return [4 /*yield*/, idb_1.default.open(dbInfo.name, dbInfo.version, function (upgradeDB) {\n                            upgradeDBWithTableList(upgradeDB, dbInfo.tableList);\n                        })];\n                case 2:\n                    db = _a.sent();\n                    return [2 /*return*/, db];\n            }\n        });\n    });\n}\nfunction openDBManager() {\n    return __awaiter(this, void 0, void 0, function () {\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0: return [4 /*yield*/, idb_1.default.open(IDB_MANAGER_DB_NAME, IDB_MANAGER_VERSION, \n                    // In case DB Manager has not been created.\n                    function (upgradeDB) {\n                        upgradeDBManager(upgradeDB);\n                    })];\n                case 1: return [2 /*return*/, _a.sent()];\n            }\n        });\n    });\n}\nfunction openDB(dbName) {\n    return __awaiter(this, void 0, void 0, function () {\n        var dbManager, dbAlreadyInManager, db;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0: return [4 /*yield*/, openDBManager()];\n                case 1:\n                    dbManager = _a.sent();\n                    return [4 /*yield*/, getItemFromDB(dbManager, IDB_MANAGER_DB_TABLE_NAME, dbName)];\n                case 2:\n                    dbAlreadyInManager = (_a.sent());\n                    dbManager.close();\n                    if (!dbAlreadyInManager) return [3 /*break*/, 4];\n                    return [4 /*yield*/, idb_1.default.open(dbAlreadyInManager.dbName, dbAlreadyInManager.version, \n                        // In case this DB has not been created.\n                        function (upgradeDB) {\n                            upgradeDBWithTableList(upgradeDB, dbAlreadyInManager.tableList || []);\n                        })];\n                case 3:\n                    db = _a.sent();\n                    return [2 /*return*/, db];\n                case 4: return [2 /*return*/, null];\n            }\n        });\n    });\n}\nfunction getItemFromDB(db, tableName, primaryKeyValue) {\n    return __awaiter(this, void 0, void 0, function () {\n        var trans, table, itemInTable;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    if (!db.objectStoreNames.contains(tableName)) return [3 /*break*/, 2];\n                    trans = db.transaction(tableName, 'readonly');\n                    table = trans.objectStore(tableName);\n                    return [4 /*yield*/, table.get(primaryKeyValue)];\n                case 1:\n                    itemInTable = (_a.sent());\n                    return [2 /*return*/, itemUnwrapper(itemInTable)];\n                case 2: return [2 /*return*/, null];\n            }\n        });\n    });\n}\nfunction upgradeDBManager(upgradeDB) {\n    upgradeDB.createObjectStore(IDB_MANAGER_DB_TABLE_NAME, {\n        keyPath: IDB_MANAGER_DB_TABLE_INDEX_NAME\n    });\n}\nfunction upgradeDBWithTableList(upgradeDB, tableList) {\n    try {\n        tableList.forEach(function (tableConfig) {\n            // If table already exists.\n            if (upgradeDB.objectStoreNames.contains(tableConfig.tableName)) {\n                var currentTable_1 = upgradeDB\n                    .transaction(tableConfig.tableName)\n                    .objectStore(tableConfig.tableName);\n                // Create new index for present table.\n                (tableConfig.indexList || []).forEach(function (theIndex) {\n                    if (!currentTable_1.indexNames.contains(theIndex.indexName)) {\n                        currentTable_1.createIndex(theIndex.indexName, theIndex.indexName, { unique: theIndex.unique });\n                    }\n                });\n                // Else create new table.\n            }\n            else {\n                var tablePrimaryKey = tableConfig.primaryKey || 'id';\n                var tableToCreate_1 = upgradeDB.createObjectStore(tableConfig.tableName, __assign({ keyPath: tablePrimaryKey }, (tablePrimaryKey === 'id'\n                    ? { autoIncrement: true }\n                    : {})));\n                // Set index of primaryKey.\n                tableToCreate_1.createIndex(tablePrimaryKey, tablePrimaryKey, {\n                    unique: true\n                });\n                // Set indexes defined in tableConfig\n                (tableConfig.indexList || []).forEach(function (theIndex) {\n                    tableToCreate_1.createIndex(theIndex.indexName, theIndex.indexName, { unique: theIndex.unique });\n                });\n                // Set index of updateTime for data ordering priority.\n                tableToCreate_1.createIndex(UPDATETIME_KEYNAME, UPDATETIME_KEYNAME, { unique: false });\n                // Set index of expireTime for expired data deletion.\n                tableToCreate_1.createIndex(EXPIRETIME_KEYNAME, EXPIRETIME_KEYNAME, { unique: false });\n            }\n        });\n    }\n    catch (e) {\n        upgradeDB.close(); // Close upgraded DB to trigger the failure of this opening process.\n    }\n}\nfunction atomicTrans(transaction, db, tryStatement) {\n    return __awaiter(this, void 0, void 0, function () {\n        var transError_1, e_1;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    _a.trys.push([0, 2, 7, 8]);\n                    return [4 /*yield*/, tryStatement()];\n                case 1:\n                    _a.sent();\n                    return [3 /*break*/, 8];\n                case 2:\n                    transError_1 = _a.sent();\n                    try {\n                        transaction.abort();\n                    }\n                    catch (e) {\n                        // Do nothing if transaction abort failed.\n                    }\n                    _a.label = 3;\n                case 3:\n                    _a.trys.push([3, 5, , 6]);\n                    // Catch the Promise error caused by transaction abortion\n                    return [4 /*yield*/, transaction.complete];\n                case 4:\n                    // Catch the Promise error caused by transaction abortion\n                    _a.sent();\n                    return [3 /*break*/, 6];\n                case 5:\n                    e_1 = _a.sent();\n                    throw transError_1;\n                case 6: return [3 /*break*/, 8];\n                case 7:\n                    db.close();\n                    return [7 /*endfinally*/];\n                case 8: return [2 /*return*/];\n            }\n        });\n    });\n}\nfunction deleteItemsFromDB(db, tableIndexRanges) {\n    return __awaiter(this, void 0, void 0, function () {\n        var validRanges, dedupTableNameList, deleteItemsTrans;\n        var _this = this;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    validRanges = tableIndexRanges.filter(function (indexRange) {\n                        return db.objectStoreNames.contains(indexRange.tableName);\n                    });\n                    dedupTableNameList = utils_1.deduplicateList(validRanges.map(function (tableIndexRange) { return tableIndexRange.tableName; }));\n                    deleteItemsTrans = db.transaction(dedupTableNameList, 'readwrite');\n                    return [4 /*yield*/, atomicTrans(deleteItemsTrans, db, function () { return __awaiter(_this, void 0, void 0, function () {\n                            var _i, validRanges_1, tableIndexRange, tableName, indexRange, table, index, cursor;\n                            return __generator(this, function (_a) {\n                                switch (_a.label) {\n                                    case 0:\n                                        _i = 0, validRanges_1 = validRanges;\n                                        _a.label = 1;\n                                    case 1:\n                                        if (!(_i < validRanges_1.length)) return [3 /*break*/, 8];\n                                        tableIndexRange = validRanges_1[_i];\n                                        tableName = tableIndexRange.tableName, indexRange = tableIndexRange.indexRange;\n                                        table = deleteItemsTrans.objectStore(tableName);\n                                        if (!!indexRange) return [3 /*break*/, 3];\n                                        return [4 /*yield*/, table.clear()];\n                                    case 2:\n                                        _a.sent();\n                                        return [3 /*break*/, 7];\n                                    case 3:\n                                        index = table.index(indexRange.indexName);\n                                        return [4 /*yield*/, index.openCursor(indexRange2DBKey(indexRange))];\n                                    case 4:\n                                        cursor = _a.sent();\n                                        _a.label = 5;\n                                    case 5:\n                                        if (!cursor) return [3 /*break*/, 7];\n                                        table.delete(cursor.primaryKey);\n                                        return [4 /*yield*/, cursor.continue()];\n                                    case 6:\n                                        cursor = _a.sent();\n                                        return [3 /*break*/, 5];\n                                    case 7:\n                                        _i++;\n                                        return [3 /*break*/, 1];\n                                    case 8: return [2 /*return*/];\n                                }\n                            });\n                        }); })];\n                case 1:\n                    _a.sent();\n                    return [2 /*return*/];\n            }\n        });\n    });\n}\nfunction addItems(dbInfo, items) {\n    return __awaiter(this, void 0, void 0, function () {\n        var dedupTableNameList, db, addItemsTrans;\n        var _this = this;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    dedupTableNameList = utils_1.deduplicateList(items.map(function (item) { return item.tableName; }));\n                    return [4 /*yield*/, deleteItems(dbInfo.name, dedupTableNameList.map(function (tableName) {\n                            return {\n                                tableName: tableName,\n                                indexRange: {\n                                    indexName: EXPIRETIME_KEYNAME,\n                                    upperIndex: +new Date(),\n                                    upperExclusive: false\n                                }\n                            };\n                        }))];\n                case 1:\n                    _a.sent();\n                    return [4 /*yield*/, createDB(dbInfo)];\n                case 2:\n                    db = _a.sent();\n                    addItemsTrans = db.transaction(dedupTableNameList, 'readwrite');\n                    return [4 /*yield*/, atomicTrans(addItemsTrans, db, function () { return __awaiter(_this, void 0, void 0, function () {\n                            var _i, items_1, item, table;\n                            return __generator(this, function (_a) {\n                                switch (_a.label) {\n                                    case 0:\n                                        _i = 0, items_1 = items;\n                                        _a.label = 1;\n                                    case 1:\n                                        if (!(_i < items_1.length)) return [3 /*break*/, 4];\n                                        item = items_1[_i];\n                                        table = addItemsTrans.objectStore(item.tableName);\n                                        return [4 /*yield*/, table.put(itemWrapper(item))];\n                                    case 2:\n                                        _a.sent();\n                                        _a.label = 3;\n                                    case 3:\n                                        _i++;\n                                        return [3 /*break*/, 1];\n                                    case 4: return [2 /*return*/];\n                                }\n                            });\n                        }); })];\n                case 3:\n                    _a.sent();\n                    return [2 /*return*/];\n            }\n        });\n    });\n}\nexports.addItems = addItems;\nfunction getItem(dbName, tableName, primaryKeyValue) {\n    return __awaiter(this, void 0, void 0, function () {\n        var db, item, e_2;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0: return [4 /*yield*/, openDB(dbName)];\n                case 1:\n                    db = _a.sent();\n                    if (!db) return [3 /*break*/, 7];\n                    _a.label = 2;\n                case 2:\n                    _a.trys.push([2, 4, 5, 6]);\n                    return [4 /*yield*/, getItemFromDB(db, tableName, primaryKeyValue)];\n                case 3:\n                    item = _a.sent();\n                    return [2 /*return*/, item];\n                case 4:\n                    e_2 = _a.sent();\n                    throw e_2;\n                case 5:\n                    db.close();\n                    return [7 /*endfinally*/];\n                case 6: return [3 /*break*/, 8];\n                case 7: return [2 /*return*/, null];\n                case 8: return [2 /*return*/];\n            }\n        });\n    });\n}\nexports.getItem = getItem;\nfunction getItemsInRange(dbName, tableIndexRange) {\n    return __awaiter(this, void 0, void 0, function () {\n        var tableName, indexRange, db, items, trans, table, wrappedItems, index, cursor, item, e_3;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    tableName = tableIndexRange.tableName, indexRange = tableIndexRange.indexRange;\n                    return [4 /*yield*/, openDB(dbName)];\n                case 1:\n                    db = _a.sent();\n                    if (!db) return [3 /*break*/, 13];\n                    _a.label = 2;\n                case 2:\n                    _a.trys.push([2, 10, 11, 12]);\n                    items = [];\n                    if (!!db.objectStoreNames.contains(tableName)) return [3 /*break*/, 3];\n                    return [3 /*break*/, 9];\n                case 3:\n                    trans = db.transaction(tableName, 'readonly');\n                    table = trans.objectStore(tableName);\n                    if (!!indexRange) return [3 /*break*/, 5];\n                    return [4 /*yield*/, table.getAll()];\n                case 4:\n                    wrappedItems = _a.sent();\n                    items = (wrappedItems || [])\n                        .map(itemUnwrapper)\n                        .filter(function (item) {\n                        return item !== null;\n                    });\n                    return [3 /*break*/, 9];\n                case 5:\n                    index = table.index(indexRange.indexName);\n                    return [4 /*yield*/, index.openCursor(indexRange2DBKey(indexRange))];\n                case 6:\n                    cursor = _a.sent();\n                    _a.label = 7;\n                case 7:\n                    if (!cursor) return [3 /*break*/, 9];\n                    item = itemUnwrapper(cursor.value);\n                    item && items.push(item);\n                    return [4 /*yield*/, cursor.continue()];\n                case 8:\n                    cursor = _a.sent();\n                    return [3 /*break*/, 7];\n                case 9: return [2 /*return*/, items];\n                case 10:\n                    e_3 = _a.sent();\n                    throw e_3;\n                case 11:\n                    db.close();\n                    return [7 /*endfinally*/];\n                case 12: return [3 /*break*/, 14];\n                case 13: return [2 /*return*/, []];\n                case 14: return [2 /*return*/];\n            }\n        });\n    });\n}\nexports.getItemsInRange = getItemsInRange;\nfunction deleteDB(dbName) {\n    return __awaiter(this, void 0, void 0, function () {\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0: return [4 /*yield*/, unregisterDBInManager(dbName)];\n                case 1:\n                    _a.sent();\n                    return [4 /*yield*/, idb_1.default.delete(dbName)];\n                case 2:\n                    _a.sent();\n                    return [2 /*return*/];\n            }\n        });\n    });\n}\nexports.deleteDB = deleteDB;\nfunction deleteItems(dbName, tableIndexRanges) {\n    return __awaiter(this, void 0, void 0, function () {\n        var db;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0: return [4 /*yield*/, openDB(dbName)];\n                case 1:\n                    db = _a.sent();\n                    if (!db) return [3 /*break*/, 3];\n                    return [4 /*yield*/, deleteItemsFromDB(db, tableIndexRanges)];\n                case 2:\n                    _a.sent();\n                    return [3 /*break*/, 4];\n                case 3: \n                // If db does not exist, no need to deleteItems at all.\n                return [2 /*return*/];\n                case 4: return [2 /*return*/];\n            }\n        });\n    });\n}\nexports.deleteItems = deleteItems;\nexports.default = {\n    addItems: addItems,\n    getItem: getItem,\n    getItemsInRange: getItemsInRange,\n    deleteDB: deleteDB,\n    deleteItems: deleteItems\n};\n\n\n//# sourceURL=webpack://IDBM/./build/db_wrapper.js?");

/***/ }),

/***/ "./build/index.js":
/*!************************!*\
  !*** ./build/index.js ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar db_env_checker_1 = __webpack_require__(/*! ./lib/db_env_checker */ \"./build/lib/db_env_checker.js\");\nvar db_wrapper_1 = __webpack_require__(/*! ./db_wrapper */ \"./build/db_wrapper.js\");\nvar utils_1 = __webpack_require__(/*! ./lib/utils */ \"./build/lib/utils.js\");\nvar DEFAULT_DB_VERSION = 1;\nvar OPTIONAL = true;\nfunction customDBConfigChecker(dbConfig) {\n    utils_1.paramChecker(dbConfig, utils_1.ParamCheckerEnum.NotNullObject, 'dbConfig', !OPTIONAL);\n    utils_1.paramChecker(dbConfig.dbName, utils_1.ParamCheckerEnum.String, 'dbName', !OPTIONAL);\n    utils_1.paramChecker(dbConfig.dbVersion, utils_1.ParamCheckerEnum.NonNegativeInteger, 'dbVersion', OPTIONAL);\n    utils_1.paramChecker(dbConfig.itemDuration, utils_1.ParamCheckerEnum.NonNegativeInteger, 'itemDuration of dbConfig', OPTIONAL);\n    utils_1.paramChecker(dbConfig.tables, utils_1.ParamCheckerEnum.NotNullObject, 'tables', OPTIONAL);\n    Object.keys(dbConfig.tables || {}).forEach(function (tableName) {\n        var tableConfig = dbConfig.tables[tableName];\n        utils_1.paramChecker(tableConfig.primaryKey, utils_1.ParamCheckerEnum.String, 'primaryKey', OPTIONAL);\n        utils_1.paramChecker(tableConfig.itemDuration, utils_1.ParamCheckerEnum.NonNegativeInteger, 'itemDuration of table', OPTIONAL);\n        utils_1.paramChecker(tableConfig.indexList, utils_1.ParamCheckerEnum.Array, 'indexList', OPTIONAL);\n        (tableConfig.indexList || []).forEach(function (index) {\n            utils_1.paramChecker(index.indexName, utils_1.ParamCheckerEnum.String, 'indexName', !OPTIONAL);\n            utils_1.paramChecker(index.unique, utils_1.ParamCheckerEnum.Boolean, 'unique', OPTIONAL);\n        });\n    });\n}\nfunction customDBAddItemsParamChecker(items, tableListInDB) {\n    utils_1.paramChecker(items, utils_1.ParamCheckerEnum.Array, 'items', !OPTIONAL);\n    items.forEach(function (itemOfTable) {\n        utils_1.paramChecker(itemOfTable.tableName, utils_1.ParamCheckerEnum.String, \"item's tableName\", !OPTIONAL);\n        utils_1.paramChecker(itemOfTable.itemDuration, utils_1.ParamCheckerEnum.NonNegativeInteger, \"item's itemDuration\", OPTIONAL);\n        var theTable = tableListInDB.filter(function (table) { return table.tableName === itemOfTable.tableName; })[0];\n        if (!theTable) {\n            throw new Error(\"Table \" + itemOfTable.tableName + \" does not exist\");\n        }\n        else if (theTable.primaryKey !== undefined &&\n            Object.getOwnPropertyNames(itemOfTable.item).indexOf(theTable.primaryKey) < 0) {\n            throw new Error(\"primaryKey is needed for item in table \" + itemOfTable.tableName);\n        }\n    });\n}\nfunction tableIndexRangeParamChecker(tableIndexRange) {\n    utils_1.paramChecker(tableIndexRange, utils_1.ParamCheckerEnum.NotNullObject, 'tableIndexRange', !OPTIONAL);\n    utils_1.paramChecker(tableIndexRange.tableName, utils_1.ParamCheckerEnum.String, \"tableIndexRange's\", !OPTIONAL);\n    utils_1.paramChecker(tableIndexRange.indexRange, utils_1.ParamCheckerEnum.NotNullObject, \"tableIndexRange's indexRange\", OPTIONAL);\n    if (tableIndexRange.indexRange) {\n        var _a = tableIndexRange.indexRange, indexName = _a.indexName, onlyIndex = _a.onlyIndex, lowerIndex = _a.lowerIndex, upperIndex = _a.upperIndex, lowerExclusive = _a.lowerExclusive, upperExclusive = _a.upperExclusive;\n        utils_1.paramChecker(indexName, utils_1.ParamCheckerEnum.String, \"indexRange's indexName\", !OPTIONAL);\n        if (onlyIndex === undefined && lowerIndex === undefined && upperIndex === undefined) {\n            throw new Error('indexRange should have bounds or value for the index');\n        }\n        else if (lowerIndex !== undefined && upperIndex !== undefined && lowerIndex >= upperIndex) {\n            throw new Error('lowerIndex should be less than upperIndex');\n        }\n        if (lowerIndex && upperIndex)\n            utils_1.paramChecker(lowerExclusive, utils_1.ParamCheckerEnum.Boolean, \"indexRange's lowerExclusive\", OPTIONAL);\n        utils_1.paramChecker(upperExclusive, utils_1.ParamCheckerEnum.Boolean, \"indexRange's upperExclusive\", OPTIONAL);\n    }\n}\nfunction idbIsSupported() {\n    try {\n        db_env_checker_1.default();\n        return true;\n    }\n    catch (e) {\n        return false;\n    }\n}\nexports.idbIsSupported = idbIsSupported;\nvar CustomDB = /** @class */ (function () {\n    function CustomDB(dbConfig) {\n        db_env_checker_1.default();\n        customDBConfigChecker(dbConfig);\n        this.name = dbConfig.dbName;\n        this.version = utils_1.optionWithBackup(dbConfig.dbVersion, DEFAULT_DB_VERSION);\n        this.tableList = Object.keys(dbConfig.tables || {}).map(function (tableName) {\n            return __assign({ tableName: tableName }, dbConfig.tables[tableName]);\n        });\n        this.itemDuration = dbConfig.itemDuration;\n    }\n    CustomDB.prototype.addItems = function (itemConfigs) {\n        return __awaiter(this, void 0, void 0, function () {\n            var itemDurationOverrider, itemsWithDuration;\n            var _this = this;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        itemDurationOverrider = function (ofDB, ofTable, ofItem) {\n                            if (ofItem !== undefined) {\n                                return ofItem;\n                            }\n                            else if (ofTable !== undefined) {\n                                return ofTable;\n                            }\n                            else {\n                                return ofDB;\n                            }\n                        };\n                        customDBAddItemsParamChecker(itemConfigs, this.tableList);\n                        itemsWithDuration = itemConfigs.map(function (itemConfig) {\n                            var theTable = _this.tableList.filter(function (table) { return table.tableName === itemConfig.tableName; })[0];\n                            return __assign({ itemDuration: itemDurationOverrider(_this.itemDuration, theTable.itemDuration, itemConfig.itemDuration) }, itemConfig);\n                        });\n                        return [4 /*yield*/, db_wrapper_1.default.addItems({\n                                name: this.name,\n                                tableList: this.tableList,\n                                version: this.version\n                            }, itemsWithDuration)];\n                    case 1:\n                        _a.sent();\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    CustomDB.prototype.getItem = function (tableName, primaryKeyValue) {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, getItemFromDB(this.name, tableName, primaryKeyValue)];\n                    case 1: return [2 /*return*/, _a.sent()];\n                }\n            });\n        });\n    };\n    CustomDB.prototype.getItemsInRange = function (tableIndexRange) {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, getItemsInRangeFromDB(this.name, tableIndexRange)];\n                    case 1: return [2 /*return*/, _a.sent()];\n                }\n            });\n        });\n    };\n    CustomDB.prototype.deleteItemsInRange = function (tableIndexRanges) {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        utils_1.paramChecker(tableIndexRanges, utils_1.ParamCheckerEnum.Array, 'tableIndexRanges', !OPTIONAL);\n                        tableIndexRanges.forEach(function (tableIndexRange) {\n                            tableIndexRangeParamChecker(tableIndexRange);\n                        });\n                        return [4 /*yield*/, db_wrapper_1.default.deleteItems(this.name, tableIndexRanges)];\n                    case 1:\n                        _a.sent();\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    return CustomDB;\n}());\nexports.CustomDB = CustomDB;\nfunction deleteDB(dbName) {\n    return __awaiter(this, void 0, void 0, function () {\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    db_env_checker_1.default();\n                    utils_1.paramChecker(dbName, utils_1.ParamCheckerEnum.String, 'dbName', !OPTIONAL);\n                    return [4 /*yield*/, db_wrapper_1.default.deleteDB(dbName)];\n                case 1:\n                    _a.sent();\n                    return [2 /*return*/];\n            }\n        });\n    });\n}\nexports.deleteDB = deleteDB;\nfunction getItemFromDB(dbName, tableName, primaryKeyValue) {\n    return __awaiter(this, void 0, void 0, function () {\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    utils_1.paramChecker(dbName, utils_1.ParamCheckerEnum.String, 'dbName', !OPTIONAL);\n                    utils_1.paramChecker(tableName, utils_1.ParamCheckerEnum.String, 'tableName', !OPTIONAL);\n                    return [4 /*yield*/, db_wrapper_1.default.getItem(dbName, tableName, primaryKeyValue)];\n                case 1: return [2 /*return*/, _a.sent()];\n            }\n        });\n    });\n}\nexports.getItemFromDB = getItemFromDB;\nfunction getItemsInRangeFromDB(dbName, tableIndexRange) {\n    return __awaiter(this, void 0, void 0, function () {\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    utils_1.paramChecker(dbName, utils_1.ParamCheckerEnum.String, 'dbName', !OPTIONAL);\n                    tableIndexRangeParamChecker(tableIndexRange);\n                    return [4 /*yield*/, db_wrapper_1.default.getItemsInRange(dbName, tableIndexRange)];\n                case 1: return [2 /*return*/, _a.sent()];\n            }\n        });\n    });\n}\nexports.getItemsInRangeFromDB = getItemsInRangeFromDB;\nexports.default = {\n    idbIsSupported: idbIsSupported,\n    CustomDB: CustomDB,\n    deleteDB: deleteDB,\n    getItemFromDB: getItemFromDB,\n    getItemsInRangeFromDB: getItemsInRangeFromDB\n};\n\n\n//# sourceURL=webpack://IDBM/./build/index.js?");

/***/ }),

/***/ "./build/lib/db_env_checker.js":
/*!*************************************!*\
  !*** ./build/lib/db_env_checker.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @file IndexedDB compatibility checker\n */\nfunction default_1() {\n    if (!window) {\n        throw new Error('idb-managed can not run in non-browser environment');\n    }\n    for (var _i = 0, _a = [\n        'indexedDB',\n        'IDBDatabase',\n        'IDBObjectStore',\n        'IDBTransaction',\n        'IDBIndex',\n        'IDBCursor',\n        'IDBKeyRange',\n        'IDBRequest'\n    ]; _i < _a.length; _i++) {\n        var property = _a[_i];\n        // @ts-ignore\n        if (!window.hasOwnProperty(property) || !window[property]) {\n            throw new Error(property + \" is not supported in window\");\n        }\n    }\n}\nexports.default = default_1;\n\n\n//# sourceURL=webpack://IDBM/./build/lib/db_env_checker.js?");

/***/ }),

/***/ "./build/lib/idb.js":
/*!**************************!*\
  !*** ./build/lib/idb.js ***!
  \**************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/**\n * @file Codes in this file are based on https://raw.githubusercontent.com/jakearchibald/idb/v2.1.3/lib/idb.js, modified to check whether some db properties exist before proxy methods execute.\n */\n\nfunction toArray(arr) {\n    return Array.prototype.slice.call(arr);\n}\n\nfunction promisifyRequest(request) {\n    return new Promise(function(resolve, reject) {\n        request.onsuccess = function() {\n            resolve(request.result);\n        };\n\n        request.onerror = function() {\n            reject(request.error);\n        };\n    });\n}\n\nfunction promisifyRequestCall(obj, method, args) {\n    var request;\n    var p = new Promise(function(resolve, reject) {\n        request = obj[method].apply(obj, args);\n        promisifyRequest(request).then(resolve, reject);\n    });\n\n    p.request = request;\n    return p;\n}\n\nfunction promisifyCursorRequestCall(obj, method, args) {\n    var p = promisifyRequestCall(obj, method, args);\n    return p.then(function(value) {\n        if (!value) return;\n        return new Cursor(value, p.request);\n    });\n}\n\nfunction proxyProperties(ProxyClass, targetProp, properties) {\n    properties.forEach(function(prop) {\n        Object.defineProperty(ProxyClass.prototype, prop, {\n            get: function() {\n                return this[targetProp][prop];\n            },\n            set: function(val) {\n                this[targetProp][prop] = val;\n            }\n        });\n    });\n}\n\nfunction proxyRequestMethods(ProxyClass, targetProp, Constructor, properties) {\n    properties.forEach(function(prop) {\n        if (!(prop in Constructor.prototype)) return;\n        ProxyClass.prototype[prop] = function() {\n            return promisifyRequestCall(this[targetProp], prop, arguments);\n        };\n    });\n}\n\nfunction proxyMethods(ProxyClass, targetProp, Constructor, properties) {\n    properties.forEach(function(prop) {\n        if (!(prop in Constructor.prototype)) return;\n        ProxyClass.prototype[prop] = function() {\n            return this[targetProp][prop].apply(this[targetProp], arguments);\n        };\n    });\n}\n\nfunction proxyCursorRequestMethods(\n    ProxyClass,\n    targetProp,\n    Constructor,\n    properties\n) {\n    properties.forEach(function(prop) {\n        if (!(prop in Constructor.prototype)) return;\n        ProxyClass.prototype[prop] = function() {\n            return promisifyCursorRequestCall(\n                this[targetProp],\n                prop,\n                arguments\n            );\n        };\n    });\n}\n\nfunction Index(index) {\n    this._index = index;\n}\n\nfunction Cursor(cursor, request) {\n    this._cursor = cursor;\n    this._request = request;\n}\n\nfunction ObjectStore(store) {\n    this._store = store;\n}\n\nObjectStore.prototype.createIndex = function() {\n    return new Index(this._store.createIndex.apply(this._store, arguments));\n};\n\nObjectStore.prototype.index = function() {\n    return new Index(this._store.index.apply(this._store, arguments));\n};\n\nfunction Transaction(idbTransaction) {\n    this._tx = idbTransaction;\n    this.complete = new Promise(function(resolve, reject) {\n        idbTransaction.oncomplete = function() {\n            resolve();\n        };\n        idbTransaction.onerror = function() {\n            reject(idbTransaction.error);\n        };\n        idbTransaction.onabort = function() {\n            reject(idbTransaction.error);\n        };\n    });\n}\n\nTransaction.prototype.objectStore = function() {\n    return new ObjectStore(this._tx.objectStore.apply(this._tx, arguments));\n};\n\nfunction UpgradeDB(db, oldVersion, transaction) {\n    this._db = db;\n    this.oldVersion = oldVersion;\n    this.transaction = new Transaction(transaction);\n}\n\nUpgradeDB.prototype.createObjectStore = function() {\n    return new ObjectStore(\n        this._db.createObjectStore.apply(this._db, arguments)\n    );\n};\n\nfunction DB(db) {\n    this._db = db;\n}\n\nDB.prototype.transaction = function() {\n    return new Transaction(this._db.transaction.apply(this._db, arguments));\n};\n\nvar exp;\n\nfunction idbIsSupported() {\n    try {\n        [\n            'IDBIndex',\n            'IDBCursor',\n            'IDBObjectStore',\n            'IDBTransaction',\n            'IDBDatabase'\n        ].forEach(function(property) {\n            if (window && (!window[property] || !window.hasOwnProperty(property))) {\n                throw new Error(property);\n            }\n        });\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\n\nif (idbIsSupported()) {\n    proxyProperties(Index, '_index', [\n        'name',\n        'keyPath',\n        'multiEntry',\n        'unique'\n    ]);\n\n    proxyRequestMethods(Index, '_index', IDBIndex, [\n        'get',\n        'getKey',\n        'getAll',\n        'getAllKeys',\n        'count'\n    ]);\n\n    proxyCursorRequestMethods(Index, '_index', IDBIndex, [\n        'openCursor',\n        'openKeyCursor'\n    ]);\n\n    proxyProperties(Cursor, '_cursor', [\n        'direction',\n        'key',\n        'primaryKey',\n        'value'\n    ]);\n\n    proxyRequestMethods(Cursor, '_cursor', IDBCursor, ['update', 'delete']);\n\n    // proxy 'next' methods\n    ['advance', 'continue', 'continuePrimaryKey'].forEach(function(methodName) {\n        if (!(methodName in IDBCursor.prototype)) return;\n        Cursor.prototype[methodName] = function() {\n            var cursor = this;\n            var args = arguments;\n            return Promise.resolve().then(function() {\n                cursor._cursor[methodName].apply(cursor._cursor, args);\n                return promisifyRequest(cursor._request).then(function(value) {\n                    if (!value) return;\n                    return new Cursor(value, cursor._request);\n                });\n            });\n        };\n    });\n\n    proxyProperties(ObjectStore, '_store', [\n        'name',\n        'keyPath',\n        'indexNames',\n        'autoIncrement'\n    ]);\n\n    proxyRequestMethods(ObjectStore, '_store', IDBObjectStore, [\n        'put',\n        'add',\n        'delete',\n        'clear',\n        'get',\n        'getAll',\n        'getKey',\n        'getAllKeys',\n        'count'\n    ]);\n\n    proxyCursorRequestMethods(ObjectStore, '_store', IDBObjectStore, [\n        'openCursor',\n        'openKeyCursor'\n    ]);\n\n    proxyMethods(ObjectStore, '_store', IDBObjectStore, ['deleteIndex']);\n\n    proxyProperties(Transaction, '_tx', ['objectStoreNames', 'mode']);\n\n    proxyMethods(Transaction, '_tx', IDBTransaction, ['abort']);\n\n    proxyProperties(UpgradeDB, '_db', ['name', 'version', 'objectStoreNames']);\n\n    proxyMethods(UpgradeDB, '_db', IDBDatabase, ['deleteObjectStore', 'close']);\n\n    proxyProperties(DB, '_db', ['name', 'version', 'objectStoreNames']);\n\n    proxyMethods(DB, '_db', IDBDatabase, ['close']);\n\n    // Add cursor iterators\n    // TODO: remove this once browsers do the right thing with promises\n    ['openCursor', 'openKeyCursor'].forEach(function(funcName) {\n        [ObjectStore, Index].forEach(function(Constructor) {\n            // Don't create iterateKeyCursor if openKeyCursor doesn't exist.\n            if (!(funcName in Constructor.prototype)) return;\n\n            Constructor.prototype[\n                funcName.replace('open', 'iterate')\n            ] = function() {\n                var args = toArray(arguments);\n                var callback = args[args.length - 1];\n                var nativeObject = this._store || this._index;\n                var request = nativeObject[funcName].apply(\n                    nativeObject,\n                    args.slice(0, -1)\n                );\n                request.onsuccess = function() {\n                    callback(request.result);\n                };\n            };\n        });\n    });\n\n    // polyfill getAll\n    [Index, ObjectStore].forEach(function(Constructor) {\n        if (Constructor.prototype.getAll) return;\n        Constructor.prototype.getAll = function(query, count) {\n            var instance = this;\n            var items = [];\n\n            return new Promise(function(resolve) {\n                instance.iterateCursor(query, function(cursor) {\n                    if (!cursor) {\n                        resolve(items);\n                        return;\n                    }\n                    items.push(cursor.value);\n\n                    if (count !== undefined && items.length == count) {\n                        resolve(items);\n                        return;\n                    }\n                    cursor.continue();\n                });\n            });\n        };\n    });\n    exp = {\n        open: function(name, version, upgradeCallback) {\n            var p = promisifyRequestCall(indexedDB, 'open', [name, version]);\n            var request = p.request;\n            if (request) {\n                request.onupgradeneeded = function(event) {\n                    if (upgradeCallback) {\n                        upgradeCallback(\n                            new UpgradeDB(\n                                request.result,\n                                event.oldVersion,\n                                request.transaction\n                            )\n                        );\n                    }\n                };\n            }\n\n            return p.then(function(db) {\n                return new DB(db);\n            });\n        },\n        delete: function(name) {\n            return promisifyRequestCall(indexedDB, 'deleteDatabase', [name]);\n        }\n    };\n} else {\n    var errorMsg = 'indexedDB is not supported';\n    exp = {\n        open: function() {\n            return Promise.reject(new Error(errorMsg));\n        },\n        delete: function() {\n            return Promise.reject(new Error(errorMsg));\n        }\n    };\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (exp);\n\n//# sourceURL=webpack://IDBM/./build/lib/idb.js?");

/***/ }),

/***/ "./build/lib/utils.js":
/*!****************************!*\
  !*** ./build/lib/utils.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n;\nexports.ParamCheckerEnum = {\n    NonNegativeInteger: {\n        rule: isNonNegativeInteger,\n        desc: 'needs to be a non-negative integer'\n    },\n    NotNullObject: {\n        rule: function (param) {\n            return param && typeof param === 'object';\n        },\n        desc: 'needs to be a not-null object'\n    },\n    String: {\n        rule: function (param) {\n            return typeof param === 'string';\n        },\n        desc: 'needs to be a string'\n    },\n    Array: {\n        rule: function (param) {\n            return param instanceof Array;\n        },\n        desc: 'needs to be an Array'\n    },\n    Boolean: {\n        rule: function (param) {\n            return typeof param === 'boolean';\n        },\n        desc: 'needs to be a boolean'\n    }\n};\nfunction isNonNegativeInteger(x) {\n    return !isNaN(x) && x >= 0;\n}\nexports.isNonNegativeInteger = isNonNegativeInteger;\nfunction optionWithBackup(param, backup) {\n    return param !== undefined ? param : backup;\n}\nexports.optionWithBackup = optionWithBackup;\nfunction paramChecker(param, checker, paramName, optional) {\n    var exp = paramName + \" \" + checker.desc;\n    if (optional) {\n        if (param !== undefined && !checker.rule(param)) {\n            throw new Error(exp + \" if defined\");\n        }\n    }\n    else {\n        if (!checker.rule(param)) {\n            throw new Error(exp);\n        }\n    }\n}\nexports.paramChecker = paramChecker;\nfunction deduplicateList(list) {\n    var deduplicatedList = list.reduce(function (accumulator, currentItem) {\n        if (accumulator.indexOf(currentItem) < 0) {\n            return accumulator.concat(currentItem);\n        }\n        else {\n            return accumulator;\n        }\n    }, []);\n    return deduplicatedList;\n}\nexports.deduplicateList = deduplicateList;\n\n\n//# sourceURL=webpack://IDBM/./build/lib/utils.js?");

/***/ }),

/***/ 0:
/*!******************************!*\
  !*** multi ./build/index.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ./build/index.js */\"./build/index.js\");\n\n\n//# sourceURL=webpack://IDBM/multi_./build/index.js?");

/***/ })

/******/ });
});