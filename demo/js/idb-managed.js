(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["IDBM"] = factory();
	else
		root["IDBM"] = factory();
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/js/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/idb/build/cjs/chunk.js":
/*!*********************************************!*\
  !*** ./node_modules/idb/build/cjs/chunk.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst instanceOfAny = (object, constructors) => constructors.some(c => object instanceof c);\n\nlet idbProxyableTypes;\nlet cursorAdvanceMethods; // This is a function to prevent it throwing up in node environments.\n\nfunction getIdbProxyableTypes() {\n  return idbProxyableTypes || (idbProxyableTypes = [IDBDatabase, IDBObjectStore, IDBIndex, IDBCursor, IDBTransaction]);\n} // This is a function to prevent it throwing up in node environments.\n\n\nfunction getCursorAdvanceMethods() {\n  return cursorAdvanceMethods || (cursorAdvanceMethods = [IDBCursor.prototype.advance, IDBCursor.prototype.continue, IDBCursor.prototype.continuePrimaryKey]);\n}\n\nconst cursorRequestMap = new WeakMap();\nconst transactionDoneMap = new WeakMap();\nconst transactionStoreNamesMap = new WeakMap();\nconst transformCache = new WeakMap();\nconst reverseTransformCache = new WeakMap();\n\nfunction promisifyRequest(request) {\n  const promise = new Promise((resolve, reject) => {\n    const unlisten = () => {\n      request.removeEventListener('success', success);\n      request.removeEventListener('error', error);\n    };\n\n    const success = () => {\n      resolve(wrap(request.result));\n      unlisten();\n    };\n\n    const error = () => {\n      reject(request.error);\n      unlisten();\n    };\n\n    request.addEventListener('success', success);\n    request.addEventListener('error', error);\n  });\n  promise.then(value => {\n    // Since cursoring reuses the IDBRequest (*sigh*), we cache it for later retrieval\n    // (see wrapFunction).\n    if (value instanceof IDBCursor) {\n      cursorRequestMap.set(value, request);\n    } // Catching to avoid \"Uncaught Promise exceptions\"\n\n  }).catch(() => {}); // This mapping exists in reverseTransformCache but doesn't doesn't exist in transformCache. This\n  // is because we create many promises from a single IDBRequest.\n\n  reverseTransformCache.set(promise, request);\n  return promise;\n}\n\nfunction cacheDonePromiseForTransaction(tx) {\n  // Early bail if we've already created a done promise for this transaction.\n  if (transactionDoneMap.has(tx)) return;\n  const done = new Promise((resolve, reject) => {\n    const unlisten = () => {\n      tx.removeEventListener('complete', complete);\n      tx.removeEventListener('error', error);\n      tx.removeEventListener('abort', error);\n    };\n\n    const complete = () => {\n      resolve();\n      unlisten();\n    };\n\n    const error = () => {\n      reject(tx.error);\n      unlisten();\n    };\n\n    tx.addEventListener('complete', complete);\n    tx.addEventListener('error', error);\n    tx.addEventListener('abort', error);\n  }); // Cache it for later retrieval.\n\n  transactionDoneMap.set(tx, done);\n}\n\nlet idbProxyTraps = {\n  get(target, prop, receiver) {\n    if (target instanceof IDBTransaction) {\n      // Special handling for transaction.done.\n      if (prop === 'done') return transactionDoneMap.get(target); // Polyfill for objectStoreNames because of Edge.\n\n      if (prop === 'objectStoreNames') {\n        return target.objectStoreNames || transactionStoreNamesMap.get(target);\n      } // Make tx.store return the only store in the transaction, or undefined if there are many.\n\n\n      if (prop === 'store') {\n        return receiver.objectStoreNames[1] ? undefined : receiver.objectStore(receiver.objectStoreNames[0]);\n      }\n    } // Else transform whatever we get back.\n\n\n    return wrap(target[prop]);\n  },\n\n  has(target, prop) {\n    if (target instanceof IDBTransaction && (prop === 'done' || prop === 'store')) {\n      return true;\n    }\n\n    return prop in target;\n  }\n\n};\n\nfunction addTraps(callback) {\n  idbProxyTraps = callback(idbProxyTraps);\n}\n\nfunction wrapFunction(func) {\n  // Due to expected object equality (which is enforced by the caching in `wrap`), we\n  // only create one new func per func.\n  // Edge doesn't support objectStoreNames (booo), so we polyfill it here.\n  if (func === IDBDatabase.prototype.transaction && !('objectStoreNames' in IDBTransaction.prototype)) {\n    return function (storeNames, ...args) {\n      const tx = func.call(unwrap(this), storeNames, ...args);\n      transactionStoreNamesMap.set(tx, storeNames.sort ? storeNames.sort() : [storeNames]);\n      return wrap(tx);\n    };\n  } // Cursor methods are special, as the behaviour is a little more different to standard IDB. In\n  // IDB, you advance the cursor and wait for a new 'success' on the IDBRequest that gave you the\n  // cursor. It's kinda like a promise that can resolve with many values. That doesn't make sense\n  // with real promises, so each advance methods returns a new promise for the cursor object, or\n  // undefined if the end of the cursor has been reached.\n\n\n  if (getCursorAdvanceMethods().includes(func)) {\n    return function (...args) {\n      // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n      // the original object.\n      func.apply(unwrap(this), args);\n      return wrap(cursorRequestMap.get(this));\n    };\n  }\n\n  return function (...args) {\n    // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n    // the original object.\n    return wrap(func.apply(unwrap(this), args));\n  };\n}\n\nfunction transformCachableValue(value) {\n  if (typeof value === 'function') return wrapFunction(value); // This doesn't return, it just creates a 'done' promise for the transaction,\n  // which is later returned for transaction.done (see idbObjectHandler).\n\n  if (value instanceof IDBTransaction) cacheDonePromiseForTransaction(value);\n  if (instanceOfAny(value, getIdbProxyableTypes())) return new Proxy(value, idbProxyTraps); // Return the same value back if we're not going to transform it.\n\n  return value;\n}\n\nfunction wrap(value) {\n  // We sometimes generate multiple promises from a single IDBRequest (eg when cursoring), because\n  // IDB is weird and a single IDBRequest can yield many responses, so these can't be cached.\n  if (value instanceof IDBRequest) return promisifyRequest(value); // If we've already transformed this value before, reuse the transformed value.\n  // This is faster, but it also provides object equality.\n\n  if (transformCache.has(value)) return transformCache.get(value);\n  const newValue = transformCachableValue(value); // Not all types are transformed.\n  // These may be primitive types, so they can't be WeakMap keys.\n\n  if (newValue !== value) {\n    transformCache.set(value, newValue);\n    reverseTransformCache.set(newValue, value);\n  }\n\n  return newValue;\n}\n\nconst unwrap = value => reverseTransformCache.get(value);\n\nexports.wrap = wrap;\nexports.addTraps = addTraps;\nexports.instanceOfAny = instanceOfAny;\nexports.reverseTransformCache = reverseTransformCache;\nexports.unwrap = unwrap;\n\n//# sourceURL=webpack://IDBM/./node_modules/idb/build/cjs/chunk.js?");

/***/ }),

/***/ "./node_modules/idb/build/cjs/index.js":
/*!*********************************************!*\
  !*** ./node_modules/idb/build/cjs/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar __chunk_1 = __webpack_require__(/*! ./chunk.js */ \"./node_modules/idb/build/cjs/chunk.js\");\n/**\r\n * Open a database.\r\n *\r\n * @param name Name of the database.\r\n * @param version Schema version.\r\n * @param callbacks Additional callbacks.\r\n */\n\n\nfunction openDB(name, version, {\n  blocked,\n  upgrade,\n  blocking\n} = {}) {\n  const request = indexedDB.open(name, version);\n\n  const openPromise = __chunk_1.wrap(request);\n\n  if (upgrade) {\n    request.addEventListener('upgradeneeded', event => {\n      upgrade(__chunk_1.wrap(request.result), event.oldVersion, event.newVersion, __chunk_1.wrap(request.transaction));\n    });\n  }\n\n  if (blocked) request.addEventListener('blocked', () => blocked());\n\n  if (blocking) {\n    openPromise.then(db => db.addEventListener('versionchange', blocking)).catch(() => {});\n  }\n\n  return openPromise;\n}\n/**\r\n * Delete a database.\r\n *\r\n * @param name Name of the database.\r\n */\n\n\nfunction deleteDB(name, {\n  blocked\n} = {}) {\n  const request = indexedDB.deleteDatabase(name);\n  if (blocked) request.addEventListener('blocked', () => blocked());\n  return __chunk_1.wrap(request).then(() => undefined);\n}\n\nconst readMethods = ['get', 'getKey', 'getAll', 'getAllKeys', 'count'];\nconst writeMethods = ['put', 'add', 'delete', 'clear'];\nconst cachedMethods = new Map();\n\nfunction getMethod(target, prop) {\n  if (!(target instanceof IDBDatabase && !(prop in target) && typeof prop === 'string')) {\n    return;\n  }\n\n  if (cachedMethods.get(prop)) return cachedMethods.get(prop);\n  const targetFuncName = prop.replace(/FromIndex$/, '');\n  const useIndex = prop !== targetFuncName;\n  const isWrite = writeMethods.includes(targetFuncName);\n\n  if ( // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.\n  !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) || !(isWrite || readMethods.includes(targetFuncName))) {\n    return;\n  }\n\n  const method = async function (storeName, ...args) {\n    // isWrite ? 'readwrite' : undefined gzipps better, but fails in Edge :(\n    const tx = this.transaction(storeName, isWrite ? 'readwrite' : 'readonly');\n    let target = tx.store;\n    if (useIndex) target = target.index(args.shift());\n    const returnVal = target[targetFuncName](...args);\n    if (isWrite) await tx.done;\n    return returnVal;\n  };\n\n  cachedMethods.set(prop, method);\n  return method;\n}\n\n__chunk_1.addTraps(oldTraps => ({\n  get: (target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver),\n  has: (target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop)\n}));\n\nexports.unwrap = __chunk_1.unwrap;\nexports.wrap = __chunk_1.wrap;\nexports.openDB = openDB;\nexports.deleteDB = deleteDB;\n\n//# sourceURL=webpack://IDBM/./node_modules/idb/build/cjs/index.js?");

/***/ }),

/***/ "./src/db_wrapper.ts":
/*!***************************!*\
  !*** ./src/db_wrapper.ts ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @file Wrap idb APIs for idb-managed\n */\n// @ts-ignore\nvar index_js_1 = __webpack_require__(/*! idb/build/cjs/index.js */ \"./node_modules/idb/build/cjs/index.js\");\nvar IDB_MANAGER_VERSION = 1;\nvar IDB_MANAGER_DB_NAME = 'IDB_MANAGER_DB';\nvar IDB_MANAGER_DB_TABLE_NAME = 'IDB_MANAGER_STORE';\nvar IDB_MANAGER_DB_TABLE_INDEX_NAME = 'dbName';\nvar UPDATETIME_KEYNAME = 'updateTime';\nvar EXPIRETIME_KEYNAME = 'expireTime';\nfunction indexRange2DBKey(indexRange) {\n    var onlyIndex = indexRange.onlyIndex, lowerIndex = indexRange.lowerIndex, upperIndex = indexRange.upperIndex, _a = indexRange.lowerExclusive, lowerExclusive = _a === void 0 ? false : _a, _b = indexRange.upperExclusive, upperExclusive = _b === void 0 ? false : _b;\n    if (onlyIndex !== undefined) {\n        return IDBKeyRange.only(onlyIndex);\n    }\n    else if (lowerIndex !== undefined && upperIndex !== undefined) {\n        return IDBKeyRange.bound(lowerIndex, upperIndex, lowerExclusive, upperExclusive);\n    }\n    else if (lowerIndex !== undefined) {\n        return IDBKeyRange.lowerBound(lowerIndex, lowerExclusive);\n    }\n    else {\n        return IDBKeyRange.upperBound(upperIndex, upperExclusive);\n    }\n}\nfunction itemWrapper(itemConfig) {\n    var _a;\n    var currentTime = Date.now();\n    return __assign(__assign({}, itemConfig.item), (_a = {}, _a[UPDATETIME_KEYNAME] = currentTime, _a[EXPIRETIME_KEYNAME] = itemConfig.itemDuration !== undefined\n        ? itemConfig.itemDuration + currentTime\n        : -1, _a));\n}\nfunction itemUnwrapper(item) {\n    if (!item) {\n        return null;\n    }\n    else if (item.expireTime > 0 && item.expireTime < Date.now()) {\n        return null;\n    }\n    else {\n        delete item.updateTime;\n        delete item.expireTime;\n        return item;\n    }\n}\nfunction registerDBInManager(dbInfo) {\n    return __awaiter(this, void 0, void 0, function () {\n        var dbManager, dbAlreadyInManager, addDBTrans, table, dbItem;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0: return [4 /*yield*/, openDBManager()];\n                case 1:\n                    dbManager = _a.sent();\n                    return [4 /*yield*/, getItemFromDB(dbManager, IDB_MANAGER_DB_TABLE_NAME, dbInfo.name)];\n                case 2:\n                    dbAlreadyInManager = (_a.sent());\n                    if (!(!dbAlreadyInManager || dbInfo.version > dbAlreadyInManager.version)) return [3 /*break*/, 4];\n                    addDBTrans = dbManager.transaction(IDB_MANAGER_DB_TABLE_NAME, 'readwrite');\n                    table = addDBTrans.objectStore(IDB_MANAGER_DB_TABLE_NAME);\n                    dbItem = {\n                        dbName: dbInfo.name,\n                        tableList: dbInfo.tableList,\n                        version: dbInfo.version\n                    };\n                    table.put(itemWrapper({\n                        item: dbItem,\n                        tableName: IDB_MANAGER_DB_TABLE_NAME\n                    }));\n                    return [4 /*yield*/, addDBTrans.done];\n                case 3:\n                    _a.sent();\n                    dbManager.close();\n                    _a.label = 4;\n                case 4: return [2 /*return*/];\n            }\n        });\n    });\n}\nfunction unregisterDBInManager(dbName) {\n    return __awaiter(this, void 0, void 0, function () {\n        var dbManager, deleteTrans, table;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0: return [4 /*yield*/, openDBManager()];\n                case 1:\n                    dbManager = _a.sent();\n                    deleteTrans = dbManager.transaction(IDB_MANAGER_DB_TABLE_NAME, 'readwrite');\n                    table = deleteTrans.objectStore(IDB_MANAGER_DB_TABLE_NAME);\n                    table.delete(dbName);\n                    return [4 /*yield*/, deleteTrans.done];\n                case 2:\n                    _a.sent();\n                    dbManager.close();\n                    return [2 /*return*/];\n            }\n        });\n    });\n}\nfunction createDB(dbInfo) {\n    return __awaiter(this, void 0, void 0, function () {\n        var db;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0: return [4 /*yield*/, registerDBInManager(dbInfo)];\n                case 1:\n                    _a.sent();\n                    return [4 /*yield*/, index_js_1.openDB(dbInfo.name, dbInfo.version, {\n                            upgrade: function (upgradeDB, oldVersion, newVersion, transaction) {\n                                upgradeDBWithTableList(upgradeDB, dbInfo.tableList, transaction);\n                            }\n                        })];\n                case 2:\n                    db = _a.sent();\n                    return [2 /*return*/, db];\n            }\n        });\n    });\n}\nfunction openDBManager() {\n    return __awaiter(this, void 0, void 0, function () {\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0: return [4 /*yield*/, index_js_1.openDB(IDB_MANAGER_DB_NAME, IDB_MANAGER_VERSION, {\n                        // In case DB Manager has not been created.\n                        upgrade: function (upgradeDB) {\n                            upgradeDBManager(upgradeDB);\n                        }\n                    })];\n                case 1: return [2 /*return*/, _a.sent()];\n            }\n        });\n    });\n}\nfunction openDB(dbName) {\n    return __awaiter(this, void 0, void 0, function () {\n        var dbManager, dbAlreadyInManager, db;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0: return [4 /*yield*/, openDBManager()];\n                case 1:\n                    dbManager = _a.sent();\n                    return [4 /*yield*/, getItemFromDB(dbManager, IDB_MANAGER_DB_TABLE_NAME, dbName)];\n                case 2:\n                    dbAlreadyInManager = (_a.sent());\n                    dbManager.close();\n                    if (!dbAlreadyInManager) return [3 /*break*/, 4];\n                    return [4 /*yield*/, index_js_1.openDB(dbAlreadyInManager.dbName, dbAlreadyInManager.version, {\n                            // In case this DB has not been created.\n                            upgrade: function (upgradeDB, oldVersion, newVersion, transaction) {\n                                upgradeDBWithTableList(upgradeDB, dbAlreadyInManager.tableList || [], transaction);\n                            }\n                        })];\n                case 3:\n                    db = _a.sent();\n                    return [2 /*return*/, db];\n                case 4: return [2 /*return*/, null];\n            }\n        });\n    });\n}\nfunction getItemFromDB(db, tableName, primaryKeyValue) {\n    return __awaiter(this, void 0, void 0, function () {\n        var trans, table, itemInTable;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    if (!db.objectStoreNames.contains(tableName)) return [3 /*break*/, 2];\n                    trans = db.transaction(tableName, 'readonly');\n                    table = trans.objectStore(tableName);\n                    return [4 /*yield*/, table.get(primaryKeyValue)];\n                case 1:\n                    itemInTable = (_a.sent());\n                    return [2 /*return*/, itemUnwrapper(itemInTable)];\n                case 2: return [2 /*return*/, null];\n            }\n        });\n    });\n}\nfunction upgradeDBManager(upgradeDB) {\n    upgradeDB.createObjectStore(IDB_MANAGER_DB_TABLE_NAME, {\n        keyPath: IDB_MANAGER_DB_TABLE_INDEX_NAME\n    });\n}\nfunction upgradeDBWithTableList(upgradeDB, tableList, transaction) {\n    try {\n        tableList.forEach(function (tableConfig) {\n            // If table already exists.\n            if (upgradeDB.objectStoreNames.contains(tableConfig.tableName)) {\n                var currentTable_1 = transaction.objectStore(tableConfig.tableName);\n                // Create new index for present table.\n                (tableConfig.indexList || []).forEach(function (theIndex) {\n                    if (!currentTable_1.indexNames.contains(theIndex.indexName)) {\n                        currentTable_1.createIndex(theIndex.indexName, theIndex.indexName, { unique: theIndex.unique });\n                    }\n                });\n                // Else create new table.\n            }\n            else {\n                var tablePrimaryKey = tableConfig.primaryKey || 'id';\n                var tableToCreate_1 = upgradeDB.createObjectStore(tableConfig.tableName, __assign({ keyPath: tablePrimaryKey }, (tablePrimaryKey === 'id'\n                    ? { autoIncrement: true }\n                    : {})));\n                // Set index of primaryKey.\n                tableToCreate_1.createIndex(tablePrimaryKey, tablePrimaryKey, {\n                    unique: true\n                });\n                // Set indexes defined in tableConfig\n                (tableConfig.indexList || []).forEach(function (theIndex) {\n                    tableToCreate_1.createIndex(theIndex.indexName, theIndex.indexName, { unique: theIndex.unique });\n                });\n                // Set index of updateTime for data ordering priority.\n                tableToCreate_1.createIndex(UPDATETIME_KEYNAME, UPDATETIME_KEYNAME, { unique: false });\n                // Set index of expireTime for expired data deletion.\n                tableToCreate_1.createIndex(EXPIRETIME_KEYNAME, EXPIRETIME_KEYNAME, { unique: false });\n            }\n        });\n    }\n    catch (e) {\n        upgradeDB.close(); // Close upgraded DB to trigger the failure of this opening process.\n    }\n}\nfunction atomicTrans(transaction, db, tryStatement) {\n    return __awaiter(this, void 0, void 0, function () {\n        var transError_1, e_1;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    _a.trys.push([0, 2, 7, 8]);\n                    return [4 /*yield*/, tryStatement()];\n                case 1:\n                    _a.sent();\n                    return [3 /*break*/, 8];\n                case 2:\n                    transError_1 = _a.sent();\n                    // Abort transaction manually to keep it atomic.\n                    try {\n                        transaction.abort();\n                    }\n                    catch (e) {\n                        // Do nothing if transaction abort failed.\n                    }\n                    _a.label = 3;\n                case 3:\n                    _a.trys.push([3, 5, , 6]);\n                    // Catch the Promise error caused by transaction abortion\n                    return [4 /*yield*/, transaction.done];\n                case 4:\n                    // Catch the Promise error caused by transaction abortion\n                    _a.sent();\n                    return [3 /*break*/, 6];\n                case 5:\n                    e_1 = _a.sent();\n                    throw transError_1;\n                case 6: return [3 /*break*/, 8];\n                case 7:\n                    db.close();\n                    return [7 /*endfinally*/];\n                case 8: return [2 /*return*/];\n            }\n        });\n    });\n}\nfunction deleteItemsFromDB(db, tableIndexRanges) {\n    return __awaiter(this, void 0, void 0, function () {\n        var validRanges, dedupTableNameList, deleteItemsTrans;\n        var _this = this;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    validRanges = tableIndexRanges.filter(function (indexRange) {\n                        return db.objectStoreNames.contains(indexRange.tableName);\n                    });\n                    dedupTableNameList = Array.from(new Set(validRanges.map(function (tableIndexRange) { return tableIndexRange.tableName; })));\n                    deleteItemsTrans = db.transaction(dedupTableNameList, 'readwrite');\n                    return [4 /*yield*/, atomicTrans(deleteItemsTrans, db, function () { return __awaiter(_this, void 0, void 0, function () {\n                            var _i, validRanges_1, tableIndexRange, tableName, indexRange, table, index, cursor;\n                            return __generator(this, function (_a) {\n                                switch (_a.label) {\n                                    case 0:\n                                        _i = 0, validRanges_1 = validRanges;\n                                        _a.label = 1;\n                                    case 1:\n                                        if (!(_i < validRanges_1.length)) return [3 /*break*/, 8];\n                                        tableIndexRange = validRanges_1[_i];\n                                        tableName = tableIndexRange.tableName, indexRange = tableIndexRange.indexRange;\n                                        table = deleteItemsTrans.objectStore(tableName);\n                                        if (!!indexRange) return [3 /*break*/, 3];\n                                        return [4 /*yield*/, table.clear()];\n                                    case 2:\n                                        _a.sent();\n                                        return [3 /*break*/, 7];\n                                    case 3:\n                                        index = table.index(indexRange.indexName);\n                                        return [4 /*yield*/, index.openCursor(indexRange2DBKey(indexRange))];\n                                    case 4:\n                                        cursor = _a.sent();\n                                        _a.label = 5;\n                                    case 5:\n                                        if (!cursor) return [3 /*break*/, 7];\n                                        table.delete(cursor.primaryKey);\n                                        return [4 /*yield*/, cursor.continue()];\n                                    case 6:\n                                        cursor = _a.sent();\n                                        return [3 /*break*/, 5];\n                                    case 7:\n                                        _i++;\n                                        return [3 /*break*/, 1];\n                                    case 8: return [4 /*yield*/, deleteItemsTrans.done];\n                                    case 9:\n                                        _a.sent();\n                                        return [2 /*return*/];\n                                }\n                            });\n                        }); })];\n                case 1:\n                    _a.sent();\n                    return [2 /*return*/];\n            }\n        });\n    });\n}\nfunction addItems(dbInfo, items) {\n    return __awaiter(this, void 0, void 0, function () {\n        var dedupTableNameList, db, addItemsTrans;\n        var _this = this;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    dedupTableNameList = Array.from(new Set(items.map(function (item) { return item.tableName; })));\n                    return [4 /*yield*/, deleteItems(dbInfo.name, dedupTableNameList.map(function (tableName) {\n                            return {\n                                tableName: tableName,\n                                indexRange: {\n                                    indexName: EXPIRETIME_KEYNAME,\n                                    upperIndex: +new Date(),\n                                    upperExclusive: false\n                                }\n                            };\n                        }))];\n                case 1:\n                    _a.sent();\n                    return [4 /*yield*/, createDB(dbInfo)];\n                case 2:\n                    db = _a.sent();\n                    addItemsTrans = db.transaction(dedupTableNameList, 'readwrite');\n                    return [4 /*yield*/, atomicTrans(addItemsTrans, db, function () { return __awaiter(_this, void 0, void 0, function () {\n                            return __generator(this, function (_a) {\n                                switch (_a.label) {\n                                    case 0:\n                                        items.forEach(function (item) {\n                                            var table = addItemsTrans.objectStore(item.tableName);\n                                            table.put(itemWrapper(item));\n                                        });\n                                        return [4 /*yield*/, addItemsTrans.done];\n                                    case 1:\n                                        _a.sent();\n                                        return [2 /*return*/];\n                                }\n                            });\n                        }); })];\n                case 3:\n                    _a.sent();\n                    return [2 /*return*/];\n            }\n        });\n    });\n}\nexports.addItems = addItems;\nfunction getItem(dbName, tableName, primaryKeyValue) {\n    return __awaiter(this, void 0, void 0, function () {\n        var db, item, e_2;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0: return [4 /*yield*/, openDB(dbName)];\n                case 1:\n                    db = _a.sent();\n                    if (!db) return [3 /*break*/, 7];\n                    _a.label = 2;\n                case 2:\n                    _a.trys.push([2, 4, 5, 6]);\n                    return [4 /*yield*/, getItemFromDB(db, tableName, primaryKeyValue)];\n                case 3:\n                    item = _a.sent();\n                    return [2 /*return*/, item];\n                case 4:\n                    e_2 = _a.sent();\n                    throw e_2;\n                case 5:\n                    db.close();\n                    return [7 /*endfinally*/];\n                case 6: return [3 /*break*/, 8];\n                case 7: return [2 /*return*/, null];\n                case 8: return [2 /*return*/];\n            }\n        });\n    });\n}\nexports.getItem = getItem;\nfunction getItemsInRange(dbName, tableIndexRange) {\n    return __awaiter(this, void 0, void 0, function () {\n        var tableName, indexRange, db, items, trans, table, wrappedItems, index, cursor, item, e_3;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    tableName = tableIndexRange.tableName, indexRange = tableIndexRange.indexRange;\n                    return [4 /*yield*/, openDB(dbName)];\n                case 1:\n                    db = _a.sent();\n                    if (!db) return [3 /*break*/, 13];\n                    _a.label = 2;\n                case 2:\n                    _a.trys.push([2, 10, 11, 12]);\n                    items = [];\n                    if (!!db.objectStoreNames.contains(tableName)) return [3 /*break*/, 3];\n                    return [3 /*break*/, 9];\n                case 3:\n                    trans = db.transaction(tableName, 'readonly');\n                    table = trans.objectStore(tableName);\n                    if (!!indexRange) return [3 /*break*/, 5];\n                    return [4 /*yield*/, table.getAll()];\n                case 4:\n                    wrappedItems = _a.sent();\n                    items = (wrappedItems || []).map(itemUnwrapper);\n                    return [3 /*break*/, 9];\n                case 5:\n                    index = table.index(indexRange.indexName);\n                    return [4 /*yield*/, index.openCursor(indexRange2DBKey(indexRange))];\n                case 6:\n                    cursor = _a.sent();\n                    _a.label = 7;\n                case 7:\n                    if (!cursor) return [3 /*break*/, 9];\n                    item = itemUnwrapper(cursor.value);\n                    item && items.push(item);\n                    return [4 /*yield*/, cursor.continue()];\n                case 8:\n                    cursor = _a.sent();\n                    return [3 /*break*/, 7];\n                case 9: return [2 /*return*/, items];\n                case 10:\n                    e_3 = _a.sent();\n                    throw e_3;\n                case 11:\n                    db.close();\n                    return [7 /*endfinally*/];\n                case 12: return [3 /*break*/, 14];\n                case 13: return [2 /*return*/, []];\n                case 14: return [2 /*return*/];\n            }\n        });\n    });\n}\nexports.getItemsInRange = getItemsInRange;\nfunction deleteDB(dbName) {\n    return __awaiter(this, void 0, void 0, function () {\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0: return [4 /*yield*/, unregisterDBInManager(dbName)];\n                case 1:\n                    _a.sent();\n                    return [4 /*yield*/, index_js_1.deleteDB(dbName)];\n                case 2:\n                    _a.sent();\n                    return [2 /*return*/];\n            }\n        });\n    });\n}\nexports.deleteDB = deleteDB;\nfunction deleteItems(dbName, tableIndexRanges) {\n    return __awaiter(this, void 0, void 0, function () {\n        var db;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0: return [4 /*yield*/, openDB(dbName)];\n                case 1:\n                    db = _a.sent();\n                    if (!db) return [3 /*break*/, 3];\n                    return [4 /*yield*/, deleteItemsFromDB(db, tableIndexRanges)];\n                case 2:\n                    _a.sent();\n                    return [3 /*break*/, 4];\n                case 3: \n                // If db does not exist, no need to deleteItems at all.\n                return [2 /*return*/];\n                case 4: return [2 /*return*/];\n            }\n        });\n    });\n}\nexports.deleteItems = deleteItems;\nexports.default = {\n    addItems: addItems,\n    getItem: getItem,\n    getItemsInRange: getItemsInRange,\n    deleteDB: deleteDB,\n    deleteItems: deleteItems\n};\n\n\n//# sourceURL=webpack://IDBM/./src/db_wrapper.ts?");

/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar db_env_checker_1 = __webpack_require__(/*! ./lib/db_env_checker */ \"./src/lib/db_env_checker.ts\");\nvar db_wrapper_1 = __webpack_require__(/*! ./db_wrapper */ \"./src/db_wrapper.ts\");\nvar utils_1 = __webpack_require__(/*! ./lib/utils */ \"./src/lib/utils.ts\");\nvar DEFAULT_DB_VERSION = 1;\nvar OPTIONAL = true;\nfunction _customDBConfigChecker(dbConfig) {\n    utils_1.paramChecker(dbConfig, utils_1.ParamCheckerEnum.NotNullObject, 'dbConfig', !OPTIONAL);\n    utils_1.paramChecker(dbConfig.dbName, utils_1.ParamCheckerEnum.String, 'dbName', !OPTIONAL);\n    utils_1.paramChecker(dbConfig.dbVersion, utils_1.ParamCheckerEnum.NonNegativeInteger, 'dbVersion', OPTIONAL);\n    utils_1.paramChecker(dbConfig.itemDuration, utils_1.ParamCheckerEnum.NonNegativeInteger, 'itemDuration of dbConfig', OPTIONAL);\n    utils_1.paramChecker(dbConfig.tables, utils_1.ParamCheckerEnum.NotNullObject, 'tables', OPTIONAL);\n    Object.keys(dbConfig.tables || {}).forEach(function (tableName) {\n        var tableConfig = dbConfig.tables[tableName];\n        utils_1.paramChecker(tableConfig.primaryKey, utils_1.ParamCheckerEnum.String, 'primaryKey', OPTIONAL);\n        utils_1.paramChecker(tableConfig.itemDuration, utils_1.ParamCheckerEnum.NonNegativeInteger, 'itemDuration of table', OPTIONAL);\n        utils_1.paramChecker(tableConfig.indexList, utils_1.ParamCheckerEnum.Array, 'indexList', OPTIONAL);\n        (tableConfig.indexList || []).forEach(function (index) {\n            utils_1.paramChecker(index.indexName, utils_1.ParamCheckerEnum.String, 'indexName', !OPTIONAL);\n            utils_1.paramChecker(index.unique, utils_1.ParamCheckerEnum.Boolean, 'unique', OPTIONAL);\n        });\n    });\n}\nfunction _customDBAddItemsParamChecker(items, tableListInDB) {\n    utils_1.paramChecker(items, utils_1.ParamCheckerEnum.Array, 'items', !OPTIONAL);\n    items.forEach(function (itemOfTable) {\n        utils_1.paramChecker(itemOfTable.tableName, utils_1.ParamCheckerEnum.String, \"item's tableName\", !OPTIONAL);\n        utils_1.paramChecker(itemOfTable.itemDuration, utils_1.ParamCheckerEnum.NonNegativeInteger, \"item's itemDuration\", OPTIONAL);\n        var theTable = tableListInDB.find(function (table) { return table.tableName === itemOfTable.tableName; });\n        if (!theTable) {\n            throw \"Table \" + itemOfTable.tableName + \" does not exist\";\n        }\n        else if (theTable.primaryKey !== undefined &&\n            Object.getOwnPropertyNames(itemOfTable.item).indexOf(theTable.primaryKey) < 0) {\n            throw \"primaryKey is needed for item in table \" + itemOfTable.tableName;\n        }\n    });\n}\nfunction tableIndexRangeParamChecker(tableIndexRange) {\n    utils_1.paramChecker(tableIndexRange, utils_1.ParamCheckerEnum.NotNullObject, 'tableIndexRange', !OPTIONAL);\n    utils_1.paramChecker(tableIndexRange.tableName, utils_1.ParamCheckerEnum.String, \"tableIndexRange's\", !OPTIONAL);\n    utils_1.paramChecker(tableIndexRange.indexRange, utils_1.ParamCheckerEnum.NotNullObject, \"tableIndexRange's indexRange\", OPTIONAL);\n    if (tableIndexRange.indexRange) {\n        var _a = tableIndexRange.indexRange, indexName = _a.indexName, lowerExclusive = _a.lowerExclusive, upperExclusive = _a.upperExclusive;\n        utils_1.paramChecker(indexName, utils_1.ParamCheckerEnum.String, \"indexRange's indexName\", !OPTIONAL);\n        utils_1.paramChecker(lowerExclusive, utils_1.ParamCheckerEnum.Boolean, \"indexRange's lowerExclusive\", OPTIONAL);\n        utils_1.paramChecker(upperExclusive, utils_1.ParamCheckerEnum.Boolean, \"indexRange's upperExclusive\", OPTIONAL);\n    }\n}\nfunction idbIsSupported() {\n    try {\n        db_env_checker_1.default();\n        return true;\n    }\n    catch (e) {\n        return false;\n    }\n}\nexports.idbIsSupported = idbIsSupported;\nvar CustomDB = /** @class */ (function () {\n    function CustomDB(dbConfig) {\n        idbIsSupported();\n        _customDBConfigChecker(dbConfig);\n        this.name = dbConfig.dbName;\n        this.version = utils_1.optionWithBackup(dbConfig.dbVersion, DEFAULT_DB_VERSION);\n        this.tableList = Object.keys(dbConfig.tables || {}).map(function (tableName) {\n            return __assign({ tableName: tableName }, dbConfig.tables[tableName]);\n        });\n        this.itemDuration = dbConfig.itemDuration;\n    }\n    CustomDB.prototype.addItems = function (itemConfigs) {\n        return __awaiter(this, void 0, void 0, function () {\n            var itemDurationOverrider, itemsWithDuration;\n            var _this = this;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        itemDurationOverrider = function (ofDB, ofTable, ofItem) {\n                            if (ofItem !== undefined) {\n                                return ofItem;\n                            }\n                            else if (ofTable !== undefined) {\n                                return ofTable;\n                            }\n                            else {\n                                return ofDB;\n                            }\n                        };\n                        _customDBAddItemsParamChecker(itemConfigs, this.tableList);\n                        itemsWithDuration = itemConfigs.map(function (itemConfig) {\n                            var theTable = _this.tableList.find(function (table) { return table.tableName === itemConfig.tableName; });\n                            return __assign({ itemDuration: itemDurationOverrider(_this.itemDuration, theTable.itemDuration, itemConfig.itemDuration) }, itemConfig);\n                        });\n                        return [4 /*yield*/, db_wrapper_1.default.addItems({\n                                name: this.name,\n                                tableList: this.tableList,\n                                version: this.version\n                            }, itemsWithDuration)];\n                    case 1:\n                        _a.sent();\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    CustomDB.prototype.getItem = function (tableName, primaryKeyValue) {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, db_wrapper_1.default.getItem(this.name, tableName, primaryKeyValue)];\n                    case 1: return [2 /*return*/, _a.sent()];\n                }\n            });\n        });\n    };\n    CustomDB.prototype.getItemsInRange = function (tableIndexRange) {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        tableIndexRangeParamChecker(tableIndexRange);\n                        return [4 /*yield*/, db_wrapper_1.default.getItemsInRange(this.name, tableIndexRange)];\n                    case 1: return [2 /*return*/, _a.sent()];\n                }\n            });\n        });\n    };\n    CustomDB.prototype.deleteItemsInRange = function (tableIndexRanges) {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        utils_1.paramChecker(tableIndexRanges, utils_1.ParamCheckerEnum.Array, 'tableIndexRanges', !OPTIONAL);\n                        tableIndexRanges.forEach(function (tableIndexRange) {\n                            tableIndexRangeParamChecker(tableIndexRange);\n                        });\n                        return [4 /*yield*/, db_wrapper_1.default.deleteItems(this.name, tableIndexRanges)];\n                    case 1:\n                        _a.sent();\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    return CustomDB;\n}());\nexports.CustomDB = CustomDB;\nfunction deleteDB(dbName) {\n    return __awaiter(this, void 0, void 0, function () {\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    db_env_checker_1.default();\n                    utils_1.paramChecker(dbName, utils_1.ParamCheckerEnum.String, 'dbName', !OPTIONAL);\n                    return [4 /*yield*/, db_wrapper_1.default.deleteDB(dbName)];\n                case 1:\n                    _a.sent();\n                    return [2 /*return*/];\n            }\n        });\n    });\n}\nexports.deleteDB = deleteDB;\nexports.default = {\n    idbIsSupported: idbIsSupported,\n    CustomDB: CustomDB,\n    deleteDB: deleteDB\n};\n\n\n//# sourceURL=webpack://IDBM/./src/index.ts?");

/***/ }),

/***/ "./src/lib/db_env_checker.ts":
/*!***********************************!*\
  !*** ./src/lib/db_env_checker.ts ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @file IndexedDB compatibility checker\n */\nfunction default_1() {\n    if (!window) {\n        throw new Error('idb-managed can not run in non-browser environment');\n    }\n    for (var _i = 0, _a = [\n        'indexedDB',\n        'IDBDatabase',\n        'IDBObjectStore',\n        'IDBTransaction',\n        'IDBIndex',\n        'IDBCursor',\n        'IDBKeyRange',\n        'IDBRequest'\n    ]; _i < _a.length; _i++) {\n        var property = _a[_i];\n        // @ts-ignore\n        if (!window.hasOwnProperty(property) || !window[property]) {\n            throw new Error(property + \" is not supported in window\");\n        }\n    }\n}\nexports.default = default_1;\n\n\n//# sourceURL=webpack://IDBM/./src/lib/db_env_checker.ts?");

/***/ }),

/***/ "./src/lib/utils.ts":
/*!**************************!*\
  !*** ./src/lib/utils.ts ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n;\nexports.ParamCheckerEnum = {\n    NonNegativeInteger: {\n        rule: isNonNegativeInteger,\n        desc: 'needs to be a non-negative integer'\n    },\n    NotNullObject: {\n        rule: function (param) {\n            return param && typeof param === 'object';\n        },\n        desc: 'needs to be a not-null object'\n    },\n    String: {\n        rule: function (param) {\n            return typeof param === 'string';\n        },\n        desc: 'needs to be a string'\n    },\n    Array: {\n        rule: function (param) {\n            return param instanceof Array;\n        },\n        desc: 'needs to be an Array'\n    },\n    Boolean: {\n        rule: function (param) {\n            return typeof param === 'boolean';\n        },\n        desc: 'needs to be a boolean'\n    }\n};\nfunction isNonNegativeInteger(x) {\n    return !isNaN(x) && x >= 0;\n}\nexports.isNonNegativeInteger = isNonNegativeInteger;\nfunction optionWithBackup(param, backup) {\n    return param !== undefined ? param : backup;\n}\nexports.optionWithBackup = optionWithBackup;\nfunction paramChecker(param, checker, paramName, optional) {\n    var exp = paramName + \" \" + checker.desc;\n    if (optional) {\n        if (param !== undefined && !checker.rule(param)) {\n            throw new Error(exp + \" if defined\");\n        }\n    }\n    else {\n        if (!checker.rule(param)) {\n            throw new Error(exp);\n        }\n    }\n}\nexports.paramChecker = paramChecker;\n\n\n//# sourceURL=webpack://IDBM/./src/lib/utils.ts?");

/***/ }),

/***/ 0:
/*!****************************!*\
  !*** multi ./src/index.ts ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ./src/index.ts */\"./src/index.ts\");\n\n\n//# sourceURL=webpack://IDBM/multi_./src/index.ts?");

/***/ })

/******/ });
});