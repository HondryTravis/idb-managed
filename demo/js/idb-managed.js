(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["IDBM"] = factory();
	else
		root["IDBM"] = factory();
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/js/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/idb/build/esm/chunk.js":
/*!*********************************************!*\
  !*** ./node_modules/idb/build/esm/chunk.js ***!
  \*********************************************/
/*! exports provided: a, b, c, d, e */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return wrap; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return addTraps; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"c\", function() { return instanceOfAny; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"d\", function() { return reverseTransformCache; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"e\", function() { return unwrap; });\nconst instanceOfAny = (object, constructors) => constructors.some(c => object instanceof c);\n\nlet idbProxyableTypes;\r\nlet cursorAdvanceMethods;\r\n// This is a function to prevent it throwing up in node environments.\r\nfunction getIdbProxyableTypes() {\r\n    return (idbProxyableTypes ||\r\n        (idbProxyableTypes = [\r\n            IDBDatabase,\r\n            IDBObjectStore,\r\n            IDBIndex,\r\n            IDBCursor,\r\n            IDBTransaction,\r\n        ]));\r\n}\r\n// This is a function to prevent it throwing up in node environments.\r\nfunction getCursorAdvanceMethods() {\r\n    return (cursorAdvanceMethods ||\r\n        (cursorAdvanceMethods = [\r\n            IDBCursor.prototype.advance,\r\n            IDBCursor.prototype.continue,\r\n            IDBCursor.prototype.continuePrimaryKey,\r\n        ]));\r\n}\r\nconst cursorRequestMap = new WeakMap();\r\nconst transactionDoneMap = new WeakMap();\r\nconst transactionStoreNamesMap = new WeakMap();\r\nconst transformCache = new WeakMap();\r\nconst reverseTransformCache = new WeakMap();\r\nfunction promisifyRequest(request) {\r\n    const promise = new Promise((resolve, reject) => {\r\n        const unlisten = () => {\r\n            request.removeEventListener('success', success);\r\n            request.removeEventListener('error', error);\r\n        };\r\n        const success = () => {\r\n            resolve(wrap(request.result));\r\n            unlisten();\r\n        };\r\n        const error = () => {\r\n            reject(request.error);\r\n            unlisten();\r\n        };\r\n        request.addEventListener('success', success);\r\n        request.addEventListener('error', error);\r\n    });\r\n    promise\r\n        .then(value => {\r\n        // Since cursoring reuses the IDBRequest (*sigh*), we cache it for later retrieval\r\n        // (see wrapFunction).\r\n        if (value instanceof IDBCursor) {\r\n            cursorRequestMap.set(value, request);\r\n        }\r\n        // Catching to avoid \"Uncaught Promise exceptions\"\r\n    })\r\n        .catch(() => { });\r\n    // This mapping exists in reverseTransformCache but doesn't doesn't exist in transformCache. This\r\n    // is because we create many promises from a single IDBRequest.\r\n    reverseTransformCache.set(promise, request);\r\n    return promise;\r\n}\r\nfunction cacheDonePromiseForTransaction(tx) {\r\n    // Early bail if we've already created a done promise for this transaction.\r\n    if (transactionDoneMap.has(tx))\r\n        return;\r\n    const done = new Promise((resolve, reject) => {\r\n        const unlisten = () => {\r\n            tx.removeEventListener('complete', complete);\r\n            tx.removeEventListener('error', error);\r\n            tx.removeEventListener('abort', error);\r\n        };\r\n        const complete = () => {\r\n            resolve();\r\n            unlisten();\r\n        };\r\n        const error = () => {\r\n            reject(tx.error);\r\n            unlisten();\r\n        };\r\n        tx.addEventListener('complete', complete);\r\n        tx.addEventListener('error', error);\r\n        tx.addEventListener('abort', error);\r\n    });\r\n    // Cache it for later retrieval.\r\n    transactionDoneMap.set(tx, done);\r\n}\r\nlet idbProxyTraps = {\r\n    get(target, prop, receiver) {\r\n        if (target instanceof IDBTransaction) {\r\n            // Special handling for transaction.done.\r\n            if (prop === 'done')\r\n                return transactionDoneMap.get(target);\r\n            // Polyfill for objectStoreNames because of Edge.\r\n            if (prop === 'objectStoreNames') {\r\n                return target.objectStoreNames || transactionStoreNamesMap.get(target);\r\n            }\r\n            // Make tx.store return the only store in the transaction, or undefined if there are many.\r\n            if (prop === 'store') {\r\n                return receiver.objectStoreNames[1]\r\n                    ? undefined\r\n                    : receiver.objectStore(receiver.objectStoreNames[0]);\r\n            }\r\n        }\r\n        // Else transform whatever we get back.\r\n        return wrap(target[prop]);\r\n    },\r\n    has(target, prop) {\r\n        if (target instanceof IDBTransaction &&\r\n            (prop === 'done' || prop === 'store')) {\r\n            return true;\r\n        }\r\n        return prop in target;\r\n    },\r\n};\r\nfunction addTraps(callback) {\r\n    idbProxyTraps = callback(idbProxyTraps);\r\n}\r\nfunction wrapFunction(func) {\r\n    // Due to expected object equality (which is enforced by the caching in `wrap`), we\r\n    // only create one new func per func.\r\n    // Edge doesn't support objectStoreNames (booo), so we polyfill it here.\r\n    if (func === IDBDatabase.prototype.transaction &&\r\n        !('objectStoreNames' in IDBTransaction.prototype)) {\r\n        return function (storeNames, ...args) {\r\n            const tx = func.call(unwrap(this), storeNames, ...args);\r\n            transactionStoreNamesMap.set(tx, storeNames.sort ? storeNames.sort() : [storeNames]);\r\n            return wrap(tx);\r\n        };\r\n    }\r\n    // Cursor methods are special, as the behaviour is a little more different to standard IDB. In\r\n    // IDB, you advance the cursor and wait for a new 'success' on the IDBRequest that gave you the\r\n    // cursor. It's kinda like a promise that can resolve with many values. That doesn't make sense\r\n    // with real promises, so each advance methods returns a new promise for the cursor object, or\r\n    // undefined if the end of the cursor has been reached.\r\n    if (getCursorAdvanceMethods().includes(func)) {\r\n        return function (...args) {\r\n            // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\r\n            // the original object.\r\n            func.apply(unwrap(this), args);\r\n            return wrap(cursorRequestMap.get(this));\r\n        };\r\n    }\r\n    return function (...args) {\r\n        // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\r\n        // the original object.\r\n        return wrap(func.apply(unwrap(this), args));\r\n    };\r\n}\r\nfunction transformCachableValue(value) {\r\n    if (typeof value === 'function')\r\n        return wrapFunction(value);\r\n    // This doesn't return, it just creates a 'done' promise for the transaction,\r\n    // which is later returned for transaction.done (see idbObjectHandler).\r\n    if (value instanceof IDBTransaction)\r\n        cacheDonePromiseForTransaction(value);\r\n    if (instanceOfAny(value, getIdbProxyableTypes()))\r\n        return new Proxy(value, idbProxyTraps);\r\n    // Return the same value back if we're not going to transform it.\r\n    return value;\r\n}\r\nfunction wrap(value) {\r\n    // We sometimes generate multiple promises from a single IDBRequest (eg when cursoring), because\r\n    // IDB is weird and a single IDBRequest can yield many responses, so these can't be cached.\r\n    if (value instanceof IDBRequest)\r\n        return promisifyRequest(value);\r\n    // If we've already transformed this value before, reuse the transformed value.\r\n    // This is faster, but it also provides object equality.\r\n    if (transformCache.has(value))\r\n        return transformCache.get(value);\r\n    const newValue = transformCachableValue(value);\r\n    // Not all types are transformed.\r\n    // These may be primitive types, so they can't be WeakMap keys.\r\n    if (newValue !== value) {\r\n        transformCache.set(value, newValue);\r\n        reverseTransformCache.set(newValue, value);\r\n    }\r\n    return newValue;\r\n}\r\nconst unwrap = (value) => reverseTransformCache.get(value);\n\n\n\n\n//# sourceURL=webpack://IDBM/./node_modules/idb/build/esm/chunk.js?");

/***/ }),

/***/ "./node_modules/idb/build/esm/index.js":
/*!*********************************************!*\
  !*** ./node_modules/idb/build/esm/index.js ***!
  \*********************************************/
/*! exports provided: unwrap, wrap, openDB, deleteDB */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"openDB\", function() { return openDB; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"deleteDB\", function() { return deleteDB; });\n/* harmony import */ var _chunk_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chunk.js */ \"./node_modules/idb/build/esm/chunk.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"unwrap\", function() { return _chunk_js__WEBPACK_IMPORTED_MODULE_0__[\"e\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"wrap\", function() { return _chunk_js__WEBPACK_IMPORTED_MODULE_0__[\"a\"]; });\n\n\n\n\n/**\r\n * Open a database.\r\n *\r\n * @param name Name of the database.\r\n * @param version Schema version.\r\n * @param callbacks Additional callbacks.\r\n */\r\nfunction openDB(name, version, { blocked, upgrade, blocking } = {}) {\r\n    const request = indexedDB.open(name, version);\r\n    const openPromise = Object(_chunk_js__WEBPACK_IMPORTED_MODULE_0__[\"a\"])(request);\r\n    if (upgrade) {\r\n        request.addEventListener('upgradeneeded', event => {\r\n            upgrade(Object(_chunk_js__WEBPACK_IMPORTED_MODULE_0__[\"a\"])(request.result), event.oldVersion, event.newVersion, Object(_chunk_js__WEBPACK_IMPORTED_MODULE_0__[\"a\"])(request.transaction));\r\n        });\r\n    }\r\n    if (blocked)\r\n        request.addEventListener('blocked', () => blocked());\r\n    if (blocking) {\r\n        openPromise.then(db => db.addEventListener('versionchange', blocking)).catch(() => { });\r\n    }\r\n    return openPromise;\r\n}\r\n/**\r\n * Delete a database.\r\n *\r\n * @param name Name of the database.\r\n */\r\nfunction deleteDB(name, { blocked } = {}) {\r\n    const request = indexedDB.deleteDatabase(name);\r\n    if (blocked)\r\n        request.addEventListener('blocked', () => blocked());\r\n    return Object(_chunk_js__WEBPACK_IMPORTED_MODULE_0__[\"a\"])(request).then(() => undefined);\r\n}\n\nconst readMethods = ['get', 'getKey', 'getAll', 'getAllKeys', 'count'];\r\nconst writeMethods = ['put', 'add', 'delete', 'clear'];\r\nconst cachedMethods = new Map();\r\nfunction getMethod(target, prop) {\r\n    if (!(target instanceof IDBDatabase &&\r\n        !(prop in target) &&\r\n        typeof prop === 'string')) {\r\n        return;\r\n    }\r\n    if (cachedMethods.get(prop))\r\n        return cachedMethods.get(prop);\r\n    const targetFuncName = prop.replace(/FromIndex$/, '');\r\n    const useIndex = prop !== targetFuncName;\r\n    const isWrite = writeMethods.includes(targetFuncName);\r\n    if (\r\n    // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.\r\n    !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) ||\r\n        !(isWrite || readMethods.includes(targetFuncName))) {\r\n        return;\r\n    }\r\n    const method = async function (storeName, ...args) {\r\n        // isWrite ? 'readwrite' : undefined gzipps better, but fails in Edge :(\r\n        const tx = this.transaction(storeName, isWrite ? 'readwrite' : 'readonly');\r\n        let target = tx.store;\r\n        if (useIndex)\r\n            target = target.index(args.shift());\r\n        const returnVal = target[targetFuncName](...args);\r\n        if (isWrite)\r\n            await tx.done;\r\n        return returnVal;\r\n    };\r\n    cachedMethods.set(prop, method);\r\n    return method;\r\n}\r\nObject(_chunk_js__WEBPACK_IMPORTED_MODULE_0__[\"b\"])(oldTraps => ({\r\n    get: (target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver),\r\n    has: (target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop),\r\n}));\n\n\n\n\n//# sourceURL=webpack://IDBM/./node_modules/idb/build/esm/index.js?");

/***/ }),

/***/ "./src/db_wrapper.ts":
/*!***************************!*\
  !*** ./src/db_wrapper.ts ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst idb_1 = __webpack_require__(/*! idb */ \"./node_modules/idb/build/esm/index.js\");\nconst utils_1 = __webpack_require__(/*! ./lib/utils */ \"./src/lib/utils.ts\");\nconst formatted_result_1 = __webpack_require__(/*! ./lib/formatted_result */ \"./src/lib/formatted_result.ts\");\nconst IDB_MANAGER_VERSION = 1;\nconst IDB_MANAGER_DB_NAME = 'IDB_MANAGER_DB';\nconst IDB_MANAGER_DB_TABLE_NAME = 'IDB_MANAGER_STORE';\nconst IDB_MANAGER_DB_TABLE_INDEX_NAME = 'dbName';\nconst UPDATETIME_KEYNAME = 'updateTime';\nconst EXPIRETIME_KEYNAME = 'expireTime';\nfunction indexRange2DBKey(indexRange) {\n    const { onlyIndex, lowerIndex, upperIndex, lowerExclusive = false, upperExclusive = false } = indexRange;\n    if (onlyIndex !== undefined) {\n        return IDBKeyRange.only(onlyIndex);\n    }\n    else if (lowerIndex !== undefined && upperIndex !== undefined) {\n        return IDBKeyRange.bound(lowerIndex, upperIndex, lowerExclusive, upperExclusive);\n    }\n    else if (lowerIndex !== undefined) {\n        return IDBKeyRange.lowerBound(lowerIndex, lowerExclusive);\n    }\n    else {\n        return IDBKeyRange.upperBound(upperIndex, upperExclusive);\n    }\n}\nfunction itemWrapper(itemConfig) {\n    const currentTime = Date.now();\n    return Object.assign(Object.assign({}, itemConfig.item), {\n        [UPDATETIME_KEYNAME]: currentTime,\n        [EXPIRETIME_KEYNAME]: itemConfig.itemDuration !== undefined\n            ? itemConfig.itemDuration + currentTime\n            : -1\n    });\n}\nfunction itemUnwrapper(item) {\n    if (!item) {\n        return null;\n    }\n    else if (item.expireTime > 0 && item.expireTime < Date.now()) {\n        return null;\n    }\n    else {\n        delete item.updateTime;\n        delete item.expireTime;\n        return item;\n    }\n}\nfunction registerDBInManager(dbInfo) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const dbManager = yield openDBManager();\n        const dbAlreadyInManager = (yield getItemFromDB(dbManager, IDB_MANAGER_DB_TABLE_NAME, dbInfo.name));\n        if (dbAlreadyInManager && dbInfo.version <= dbAlreadyInManager.version) {\n            // No need to register\n            return;\n        }\n        else {\n            // update db in manager\n            const addDBTrans = dbManager.transaction(IDB_MANAGER_DB_TABLE_NAME, 'readwrite');\n            const table = addDBTrans.objectStore(IDB_MANAGER_DB_TABLE_NAME);\n            const dbItem = {\n                dbName: dbInfo.name,\n                tableList: dbInfo.tableList,\n                version: dbInfo.version\n            };\n            table.put(itemWrapper({\n                item: dbItem,\n                tableName: IDB_MANAGER_DB_TABLE_NAME\n            }));\n            yield addDBTrans.done;\n            dbManager.close();\n        }\n    });\n}\nfunction unregisterDBInManager(dbName) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const dbManager = yield openDBManager();\n        const deleteTrans = dbManager.transaction(IDB_MANAGER_DB_TABLE_NAME, 'readwrite');\n        const table = deleteTrans.objectStore(IDB_MANAGER_DB_TABLE_NAME);\n        table.delete(dbName);\n        yield deleteTrans.done;\n        dbManager.close();\n    });\n}\nfunction createDB(dbInfo) {\n    return __awaiter(this, void 0, void 0, function* () {\n        yield registerDBInManager(dbInfo);\n        const db = yield idb_1.openDB(dbInfo.name, dbInfo.version, {\n            upgrade(upgradeDB, oldVersion, newVersion, transaction) {\n                upgradeDBWithTableList(upgradeDB, dbInfo.tableList, transaction);\n            }\n        });\n        return db;\n    });\n}\nfunction openDBManager() {\n    return __awaiter(this, void 0, void 0, function* () {\n        return yield idb_1.openDB(IDB_MANAGER_DB_NAME, IDB_MANAGER_VERSION, {\n            // In case DB Manager has not been created.\n            upgrade(upgradeDB) {\n                upgradeDBManager(upgradeDB);\n            }\n        });\n    });\n}\nfunction openDB(dbName) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const dbManager = yield openDBManager();\n        const dbAlreadyInManager = (yield getItemFromDB(dbManager, IDB_MANAGER_DB_TABLE_NAME, dbName));\n        dbManager.close();\n        if (dbAlreadyInManager) {\n            const db = yield idb_1.openDB(dbAlreadyInManager.dbName, dbAlreadyInManager.version, {\n                // In case this DB has not been created.\n                upgrade(upgradeDB, oldVersion, newVersion, transaction) {\n                    upgradeDBWithTableList(upgradeDB, dbAlreadyInManager.tableList || [], transaction);\n                }\n            });\n            return db;\n        }\n        else {\n            throw formatted_result_1.default['DB_NOT_FOUND'];\n        }\n    });\n}\nfunction getItemFromDB(db, tableName, primaryKeyValue) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (db.objectStoreNames.contains(tableName)) {\n            const trans = db.transaction(tableName, 'readonly');\n            const table = trans.objectStore(tableName);\n            const itemInTable = (yield table.get(primaryKeyValue));\n            return itemUnwrapper(itemInTable);\n        }\n        else {\n            throw formatted_result_1.default['TABLE_NOT_FOUND'];\n        }\n    });\n}\nfunction upgradeDBManager(upgradeDB) {\n    upgradeDB.createObjectStore(IDB_MANAGER_DB_TABLE_NAME, {\n        keyPath: IDB_MANAGER_DB_TABLE_INDEX_NAME\n    });\n}\nfunction upgradeDBWithTableList(upgradeDB, tableList, transaction) {\n    try {\n        tableList.forEach(tableConfig => {\n            // If table already exists.\n            if (upgradeDB.objectStoreNames.contains(tableConfig.tableName)) {\n                const currentTable = transaction.objectStore(tableConfig.tableName);\n                // Create new index for present table.\n                (tableConfig.indexList || []).forEach((theIndex) => {\n                    if (!currentTable.indexNames.contains(theIndex.indexName)) {\n                        currentTable.createIndex(theIndex.indexName, theIndex.indexName, { unique: theIndex.unique });\n                    }\n                });\n                // Else create new table.\n            }\n            else {\n                const tablePrimaryKey = tableConfig.primaryKey || 'id';\n                const tableToCreate = upgradeDB.createObjectStore(tableConfig.tableName, Object.assign({ keyPath: tablePrimaryKey }, (tablePrimaryKey === 'id'\n                    ? { autoIncrement: true }\n                    : {})));\n                // Set index of primaryKey.\n                tableToCreate.createIndex(tablePrimaryKey, tablePrimaryKey, {\n                    unique: true\n                });\n                // Set indexes defined in tableConfig\n                (tableConfig.indexList || []).forEach((theIndex) => {\n                    tableToCreate.createIndex(theIndex.indexName, theIndex.indexName, { unique: theIndex.unique });\n                });\n                // Set index of updateTime for data ordering priority.\n                tableToCreate.createIndex(UPDATETIME_KEYNAME, UPDATETIME_KEYNAME, { unique: false });\n                // Set index of expireTime for expired data deletion.\n                tableToCreate.createIndex(EXPIRETIME_KEYNAME, EXPIRETIME_KEYNAME, { unique: false });\n            }\n        });\n    }\n    catch (e) {\n        console.log(e);\n        upgradeDB.close(); // Close upgraded DB to trigger the failure of this opening process.\n    }\n}\nfunction deleteItemsFromDB(db, tableIndexRanges) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const dedupTableNameList = utils_1.deduplicateList(tableIndexRanges.map(tableIndexRange => tableIndexRange.tableName));\n        dedupTableNameList.forEach(tableName => {\n            if (!db.objectStoreNames.contains(tableName)) {\n                throw formatted_result_1.default['TABLE_NOT_FOUND'];\n            }\n        });\n        const deleteItemsTrans = db.transaction(dedupTableNameList, 'readwrite');\n        try {\n            for (let tableIndexRange of tableIndexRanges) {\n                const { tableName, indexRange } = tableIndexRange;\n                const table = deleteItemsTrans.objectStore(tableName);\n                if (!indexRange) {\n                    yield table.clear();\n                }\n                else {\n                    let index = table.index(indexRange.indexName);\n                    let cursor = yield index.openCursor(indexRange2DBKey(indexRange));\n                    while (cursor) {\n                        table.delete(cursor.primaryKey);\n                        cursor = yield cursor.continue();\n                    }\n                }\n            }\n            yield deleteItemsTrans.done;\n            db.close();\n        }\n        catch (errMsg) {\n            db.close();\n            // Abort transaction manually to keep deleteItems operation atomic.\n            try {\n                deleteItemsTrans.abort();\n            }\n            catch (e) {\n                // Do nothing if transaction abort failed.\n            }\n            try {\n                // Catch the Promise error caused by transaction abortion\n                yield deleteItemsTrans.done;\n            }\n            catch (e) {\n                throw errMsg;\n            }\n        }\n    });\n}\nfunction addItems(customDB, items) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const db = yield createDB(customDB);\n        const dedupTableNameList = utils_1.deduplicateList(items.map(item => item.tableName));\n        // FIXME\n        // await deleteExpiredItemsFromTable(db, dedupTableNameList);\n        const addItemsTrans = db.transaction(dedupTableNameList, 'readwrite');\n        try {\n            items.forEach(item => {\n                const table = addItemsTrans.objectStore(item.tableName);\n                table.put(itemWrapper(item));\n            });\n            yield addItemsTrans.done;\n            db.close();\n        }\n        catch (errMsg) {\n            db.close();\n            // Abort transaction manually to keep addItems operation atomic.\n            try {\n                addItemsTrans.abort();\n            }\n            catch (e) {\n                // Do nothing if transaction abort failed.\n            }\n            try {\n                // Catch the Promise error caused by transaction abortion.\n                yield addItemsTrans.done;\n            }\n            catch (e) {\n                throw errMsg;\n            }\n        }\n    });\n}\nexports.addItems = addItems;\nfunction getItem(dbName, tableName, primaryKeyValue) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const db = yield openDB(dbName);\n        try {\n            const item = yield getItemFromDB(db, tableName, primaryKeyValue);\n            db.close();\n            return item;\n        }\n        catch (e) {\n            db.close();\n            throw e;\n        }\n    });\n}\nexports.getItem = getItem;\nfunction getItemsInRange(dbName, tableIndexRange) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const { tableName, indexRange } = tableIndexRange;\n        const db = yield openDB(dbName);\n        try {\n            if (!db.objectStoreNames.contains(tableName)) {\n                throw formatted_result_1.default['TABLE_NOT_FOUND'];\n            }\n            const trans = db.transaction(tableName, 'readonly');\n            const table = trans.objectStore(tableName);\n            let items = [];\n            // Get all items in table if indexRange is undefined\n            if (!indexRange) {\n                let wrappedItems = yield table.getAll();\n                items = (wrappedItems || []).map(itemUnwrapper);\n            }\n            else {\n                let index = table.index(indexRange.indexName);\n                let cursor = yield index.openCursor(indexRange2DBKey(indexRange));\n                while (cursor) {\n                    items.push(itemUnwrapper(cursor.value));\n                    cursor = yield cursor.continue();\n                }\n            }\n            db.close();\n            return items;\n        }\n        catch (e) {\n            db.close();\n            throw e;\n        }\n    });\n}\nexports.getItemsInRange = getItemsInRange;\nfunction deleteDB(dbName) {\n    return __awaiter(this, void 0, void 0, function* () {\n        yield unregisterDBInManager(dbName);\n        yield idb_1.deleteDB(dbName);\n    });\n}\nexports.deleteDB = deleteDB;\nfunction deleteItems(dbName, tableIndexRanges) {\n    return __awaiter(this, void 0, void 0, function* () {\n        try {\n            const db = yield openDB(dbName);\n            yield deleteItemsFromDB(db, tableIndexRanges);\n        }\n        catch (e) {\n            if (e.msg === formatted_result_1.default.DB_NOT_FOUND.msg ||\n                e.msg === formatted_result_1.default.TABLE_NOT_FOUND.msg) {\n                // If db or table does not exist, no need to deleteItems at all.\n                return;\n            }\n            else {\n                throw e;\n            }\n        }\n    });\n}\nexports.deleteItems = deleteItems;\nexports.default = {\n    addItems,\n    getItem,\n    getItemsInRange,\n    deleteDB,\n    deleteItems\n};\n\n\n//# sourceURL=webpack://IDBM/./src/db_wrapper.ts?");

/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst db_env_checker_1 = __webpack_require__(/*! ./lib/db_env_checker */ \"./src/lib/db_env_checker.ts\");\nconst formatted_result_1 = __webpack_require__(/*! ./lib/formatted_result */ \"./src/lib/formatted_result.ts\");\nconst db_wrapper_1 = __webpack_require__(/*! ./db_wrapper */ \"./src/db_wrapper.ts\");\nconst utils_1 = __webpack_require__(/*! ./lib/utils */ \"./src/lib/utils.ts\");\nconst DEFAULT_DB_VERSION = 1;\nconst OPTIONAL = true;\nfunction _customDBConfigChecker(dbConfig) {\n    utils_1.paramChecker(dbConfig, utils_1.ParamCheckerEnum.NotNullObject, 'dbConfig', !OPTIONAL);\n    utils_1.paramChecker(dbConfig.dbName, utils_1.ParamCheckerEnum.String, 'dbName', !OPTIONAL);\n    utils_1.paramChecker(dbConfig.dbVersion, utils_1.ParamCheckerEnum.NonNegativeInteger, 'dbVersion', OPTIONAL);\n    utils_1.paramChecker(dbConfig.itemDuration, utils_1.ParamCheckerEnum.NonNegativeInteger, 'itemDuration of dbConfig', OPTIONAL);\n    utils_1.paramChecker(dbConfig.tables, utils_1.ParamCheckerEnum.NotNullObject, 'tables', OPTIONAL);\n    Object.keys(dbConfig.tables || {}).forEach(tableName => {\n        const tableConfig = dbConfig.tables[tableName];\n        utils_1.paramChecker(tableConfig.primaryKey, utils_1.ParamCheckerEnum.String, 'primaryKey', OPTIONAL);\n        utils_1.paramChecker(tableConfig.itemDuration, utils_1.ParamCheckerEnum.NonNegativeInteger, 'itemDuration of table', OPTIONAL);\n        utils_1.paramChecker(tableConfig.indexList, utils_1.ParamCheckerEnum.Array, 'indexList', OPTIONAL);\n        (tableConfig.indexList || []).forEach(index => {\n            utils_1.paramChecker(index.indexName, utils_1.ParamCheckerEnum.String, 'indexName', !OPTIONAL);\n            utils_1.paramChecker(index.unique, utils_1.ParamCheckerEnum.Boolean, 'unique', OPTIONAL);\n        });\n    });\n}\nfunction _customDBAddItemsParamChecker(items, tableListInDB) {\n    utils_1.paramChecker(items, utils_1.ParamCheckerEnum.Array, 'items', !OPTIONAL);\n    items.forEach(itemOfTable => {\n        utils_1.paramChecker(itemOfTable.tableName, utils_1.ParamCheckerEnum.String, \"item's tableName\", !OPTIONAL);\n        utils_1.paramChecker(itemOfTable.itemDuration, utils_1.ParamCheckerEnum.NonNegativeInteger, \"item's itemDuration\", OPTIONAL);\n        const theTable = tableListInDB.find(table => table.tableName === itemOfTable.tableName);\n        if (!theTable) {\n            throw `Table ${itemOfTable.tableName} does not exist`;\n        }\n        else if (theTable.primaryKey !== undefined &&\n            Object.getOwnPropertyNames(itemOfTable.item).indexOf(theTable.primaryKey) < 0) {\n            throw `primaryKey is needed for item in table ${itemOfTable.tableName}`;\n        }\n    });\n}\nfunction tableIndexRangeParamChecker(tableIndexRange) {\n    utils_1.paramChecker(tableIndexRange, utils_1.ParamCheckerEnum.NotNullObject, 'tableIndexRange', !OPTIONAL);\n    utils_1.paramChecker(tableIndexRange.tableName, utils_1.ParamCheckerEnum.String, \"tableIndexRange's\", !OPTIONAL);\n    utils_1.paramChecker(tableIndexRange.indexRange, utils_1.ParamCheckerEnum.NotNullObject, \"tableIndexRange's indexRange\", OPTIONAL);\n    if (tableIndexRange.indexRange) {\n        const { indexName, lowerExclusive, upperExclusive } = tableIndexRange.indexRange;\n        utils_1.paramChecker(indexName, utils_1.ParamCheckerEnum.String, \"indexRange's indexName\", !OPTIONAL);\n        utils_1.paramChecker(lowerExclusive, utils_1.ParamCheckerEnum.Boolean, \"indexRange's lowerExclusive\", OPTIONAL);\n        utils_1.paramChecker(upperExclusive, utils_1.ParamCheckerEnum.Boolean, \"indexRange's upperExclusive\", OPTIONAL);\n    }\n}\nfunction idbIsSupported() {\n    let supportResult = db_env_checker_1.default.getResult();\n    return supportResult !== formatted_result_1.default['DB_NOT_SUPPORT'];\n}\nexports.idbIsSupported = idbIsSupported;\nclass CustomDB {\n    constructor(dbConfig) {\n        try {\n            _customDBConfigChecker(dbConfig);\n        }\n        catch (errMsg) {\n            throw formatted_result_1.default['PARAM_INVALID'].setData({\n                desc: `${errMsg}`\n            });\n        }\n        this.name = dbConfig.dbName;\n        this.version = utils_1.optionWithBackup(dbConfig.dbVersion, DEFAULT_DB_VERSION);\n        this.tableList = Object.keys(dbConfig.tables || {}).map(tableName => {\n            return Object.assign({ tableName: tableName }, dbConfig.tables[tableName]);\n        });\n        this.itemDuration = dbConfig.itemDuration;\n    }\n    addItems(items) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const itemDurationOverrider = (ofDB, ofTable, ofItem) => {\n                if (ofItem !== undefined) {\n                    return ofItem;\n                }\n                else if (ofTable !== undefined) {\n                    return ofTable;\n                }\n                else {\n                    return ofDB;\n                }\n            };\n            try {\n                _customDBAddItemsParamChecker(items, this.tableList);\n            }\n            catch (errMsg) {\n                throw formatted_result_1.default['PARAM_INVALID'].setData({\n                    desc: `${errMsg}`\n                });\n            }\n            try {\n                // Set backup itemDuration to each item\n                const itemsWithDuration = items.map(item => {\n                    const theTable = this.tableList.find(table => table.tableName === item.tableName);\n                    return Object.assign({\n                        itemDuration: itemDurationOverrider(this.itemDuration, theTable.itemDuration, item.itemDuration)\n                    }, item);\n                });\n                yield db_wrapper_1.default.addItems(this, itemsWithDuration);\n                return formatted_result_1.default['SUCC'];\n            }\n            catch (e) {\n                throw formatted_result_1.default['ADD_ITEMS_FAIL'].setData({\n                    desc: `${e}`\n                });\n            }\n        });\n    }\n    getItem(tableName, primaryKeyValue) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                return yield db_wrapper_1.default.getItem(this.name, tableName, primaryKeyValue);\n            }\n            catch (e) {\n                throw formatted_result_1.default['GET_ITEM_FAIL'].setData({\n                    desc: `${e}`\n                });\n            }\n        });\n    }\n    getItemsInRange(tableIndexRange) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                tableIndexRangeParamChecker(tableIndexRange);\n            }\n            catch (errMsg) {\n                throw formatted_result_1.default['PARAM_INVALID'].setData({\n                    desc: `${errMsg}`\n                });\n            }\n            try {\n                return yield db_wrapper_1.default.getItemsInRange(this.name, tableIndexRange);\n            }\n            catch (e) {\n                throw formatted_result_1.default['GET_IN_RANGE_FAIL'].setData({\n                    desc: `${e}`\n                });\n            }\n        });\n    }\n    deleteItemsInRange(tableIndexRanges) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                utils_1.paramChecker(tableIndexRanges, utils_1.ParamCheckerEnum.Array, 'tableIndexRanges', !OPTIONAL);\n                tableIndexRanges.forEach(tableIndexRange => {\n                    tableIndexRangeParamChecker(tableIndexRange);\n                });\n            }\n            catch (errMsg) {\n                throw formatted_result_1.default['PARAM_INVALID'].setData({\n                    desc: `${errMsg}`\n                });\n            }\n            try {\n                yield db_wrapper_1.default.deleteItems(this.name, tableIndexRanges);\n                return formatted_result_1.default['SUCC'];\n            }\n            catch (e) {\n                throw formatted_result_1.default['DELETE_ITEMS_FAIL'].setData({\n                    desc: `${e}`\n                });\n            }\n        });\n    }\n}\nexports.CustomDB = CustomDB;\nfunction deleteDB(dbName) {\n    return __awaiter(this, void 0, void 0, function* () {\n        try {\n            utils_1.paramChecker(dbName, utils_1.ParamCheckerEnum.String, 'dbName', !OPTIONAL);\n        }\n        catch (errMsg) {\n            throw formatted_result_1.default['PARAM_INVALID'].setData({\n                desc: `${errMsg}`\n            });\n        }\n        try {\n            yield db_wrapper_1.default.deleteDB(dbName);\n            return formatted_result_1.default['SUCC'];\n        }\n        catch (e) {\n            throw formatted_result_1.default['DELETE_DB_FAIL'].setData({\n                desc: `${e}`\n            });\n        }\n    });\n}\nexports.deleteDB = deleteDB;\nexports.default = {\n    idbIsSupported,\n    CustomDB,\n    deleteDB\n};\n\n\n//# sourceURL=webpack://IDBM/./src/index.ts?");

/***/ }),

/***/ "./src/lib/db_env_checker.ts":
/*!***********************************!*\
  !*** ./src/lib/db_env_checker.ts ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @file IndexedDB compatibility checker\n */\nconst formatted_result_1 = __webpack_require__(/*! ./formatted_result */ \"./src/lib/formatted_result.ts\");\nexports.default = {\n    getResult: function () {\n        if (!window) {\n            return formatted_result_1.default['DB_NOT_SUPPORT'].setData({\n                desc: 'idb-managed can not run in non-browser environment'\n            });\n        }\n        try {\n            [\n                'indexedDB',\n                'IDBDatabase',\n                'IDBObjectStore',\n                'IDBTransaction',\n                'IDBIndex',\n                'IDBCursor',\n                'IDBKeyRange'\n            ].forEach(property => {\n                if (!window.hasOwnProperty(property)) {\n                    throw formatted_result_1.default['DB_NOT_SUPPORT'].setData({\n                        desc: `${property} is not supported in window`\n                    });\n                }\n            });\n            return formatted_result_1.default['SUCC'];\n        }\n        catch (resultOb) {\n            return resultOb;\n        }\n    }\n};\n\n\n//# sourceURL=webpack://IDBM/./src/lib/db_env_checker.ts?");

/***/ }),

/***/ "./src/lib/formatted_result.ts":
/*!*************************************!*\
  !*** ./src/lib/formatted_result.ts ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @file Provide unified formatted result for idb-managed\n */\nclass ResultFormatter {\n    constructor(theCode, theMsg) {\n        this.code = theCode;\n        this.msg = theMsg;\n    }\n    setData(supplyment) {\n        this.data = Object.assign(Object.assign({}, this.data), supplyment);\n        return this;\n    }\n    toString() {\n        return `FormattedResult{code: ${this.code}, msg: ${this.msg}, data: ${JSON.stringify(this.data)}}`;\n    }\n}\nexports.ResultFormatter = ResultFormatter;\nexports.default = {\n    get DB_NOT_SUPPORT() {\n        return new ResultFormatter(100, 'IndexedDB is not supported');\n    },\n    get PARAM_INVALID() {\n        return new ResultFormatter(101, 'Invalid parameter');\n    },\n    get SUCC() {\n        return new ResultFormatter(200, 'Successfully done');\n    },\n    get DB_NOT_FOUND() {\n        return new ResultFormatter(201, 'DB does not exist');\n    },\n    get TABLE_NOT_FOUND() {\n        return new ResultFormatter(202, 'Table does not exist');\n    },\n    get OPEN_DB_FAIL() {\n        return new ResultFormatter(203, 'Open DB failed');\n    },\n    get ADD_ITEMS_FAIL() {\n        return new ResultFormatter(204, 'Add items failed');\n    },\n    get GET_ITEM_FAIL() {\n        return new ResultFormatter(205, 'Get item failed');\n    },\n    get GET_IN_RANGE_FAIL() {\n        return new ResultFormatter(206, 'Get items in range failed');\n    },\n    get DELETE_ITEMS_FAIL() {\n        return new ResultFormatter(207, 'Delete items failed');\n    },\n    get DELETE_DB_FAIL() {\n        return new ResultFormatter(208, 'Delete DB failed');\n    },\n    get UNEXPECTED_ERR() {\n        return new ResultFormatter(666, 'Some unexpected error happens');\n    }\n};\n\n\n//# sourceURL=webpack://IDBM/./src/lib/formatted_result.ts?");

/***/ }),

/***/ "./src/lib/utils.ts":
/*!**************************!*\
  !*** ./src/lib/utils.ts ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n;\nexports.ParamCheckerEnum = {\n    NonNegativeInteger: {\n        rule: isNonNegativeInteger,\n        desc: 'needs to be a non-negative integer'\n    },\n    NotNullObject: {\n        rule: (param) => {\n            return param && typeof param === 'object';\n        },\n        desc: 'needs to be a not-null object'\n    },\n    String: {\n        rule: (param) => {\n            return typeof param === 'string';\n        },\n        desc: 'needs to be a string'\n    },\n    Array: {\n        rule: (param) => {\n            return param instanceof Array;\n        },\n        desc: 'needs to be an Array'\n    },\n    Boolean: {\n        rule: (param) => {\n            return typeof param === 'boolean';\n        },\n        desc: 'needs to be a boolean'\n    }\n};\nfunction isNonNegativeInteger(x) {\n    return !isNaN(x) && x >= 0;\n}\nexports.isNonNegativeInteger = isNonNegativeInteger;\nfunction optionWithBackup(param, backup) {\n    return param !== undefined ? param : backup;\n}\nexports.optionWithBackup = optionWithBackup;\nfunction paramChecker(param, checker, paramName, optional) {\n    const exp = `${paramName} ${checker.desc}`;\n    if (optional) {\n        if (param !== undefined && !checker.rule(param)) {\n            throw `${exp} if defined`;\n        }\n    }\n    else {\n        if (!checker.rule(param)) {\n            throw `${exp}`;\n        }\n    }\n}\nexports.paramChecker = paramChecker;\nfunction deduplicateList(list) {\n    let deduplicatedList = list.reduce((accumulator, currentItem) => {\n        if (accumulator.indexOf(currentItem) < 0) {\n            return accumulator.concat(currentItem);\n        }\n        else {\n            return accumulator;\n        }\n    }, []);\n    return deduplicatedList;\n}\nexports.deduplicateList = deduplicateList;\n\n\n//# sourceURL=webpack://IDBM/./src/lib/utils.ts?");

/***/ }),

/***/ 0:
/*!****************************!*\
  !*** multi ./src/index.ts ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ./src/index.ts */\"./src/index.ts\");\n\n\n//# sourceURL=webpack://IDBM/multi_./src/index.ts?");

/***/ })

/******/ });
});