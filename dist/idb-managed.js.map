{"version":3,"sources":["webpack://IDBM/webpack/universalModuleDefinition","webpack://IDBM/webpack/bootstrap","webpack://IDBM/./node_modules/idb/build/esm/chunk.js","webpack://IDBM/./node_modules/idb/build/esm/index.js","webpack://IDBM/./src/db_wrapper.ts","webpack://IDBM/./src/index.ts","webpack://IDBM/./src/lib/db_env_checker.ts","webpack://IDBM/./src/lib/formatted_result.ts","webpack://IDBM/./src/lib/utils.ts"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;QCVA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;;;;;;;AClFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,sBAAsB,EAAE;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEiG;;;;;;;;;;;;;ACpLjG;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAsD;AACF;;AAEpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,6BAA6B,KAAK;AAClE;AACA,wBAAwB,mDAAI;AAC5B;AACA;AACA,oBAAoB,mDAAI,sDAAsD,mDAAI;AAClF,SAAS;AACT;AACA;AACA;AACA;AACA,4FAA4F,EAAE;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,UAAU,KAAK;AACxC;AACA;AACA;AACA,WAAW,mDAAI;AACf;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAQ;AACR;AACA;AACA,CAAC;;AAE2B;;;;;;;;;;;;;AC5Ef;AACb;AACA;AACA,gDAAgD,OAAO;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,+DAA+D,gBAAgB,EAAE,EAAE;AAC9G;AACA,mCAAmC,MAAM,6BAA6B,EAAE,YAAY,WAAW,EAAE;AACjG,kCAAkC,MAAM,iCAAiC,EAAE,YAAY,WAAW,EAAE;AACpG,+BAA+B,qFAAqF;AACpH;AACA,KAAK;AACL;AACA;AACA,aAAa,6BAA6B,0BAA0B,aAAa,EAAE,qBAAqB;AACxG,gBAAgB,qDAAqD,oEAAoE,aAAa,EAAE;AACxJ,sBAAsB,sBAAsB,qBAAqB,GAAG;AACpE;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC,kCAAkC,SAAS;AAC3C,kCAAkC,WAAW,UAAU;AACvD,yCAAyC,cAAc;AACvD;AACA,6GAA6G,OAAO,UAAU;AAC9H,gFAAgF,iBAAiB,OAAO;AACxG,wDAAwD,gBAAgB,QAAQ,OAAO;AACvF,8CAA8C,gBAAgB,gBAAgB,OAAO;AACrF;AACA,iCAAiC;AACjC;AACA;AACA,SAAS,YAAY,aAAa,OAAO,EAAE,UAAU,WAAW;AAChE,mCAAmC,SAAS;AAC5C;AACA;AACA,8CAA8C,cAAc;AAC5D,YAAY,mBAAO,CAAC,kDAAK;AACzB,cAAc,mBAAO,CAAC,uCAAa;AACnC,yBAAyB,mBAAO,CAAC,6DAAwB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,4BAA4B;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4FAA4F,0BAA0B;AACtH;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,mGAAmG,2BAA2B;AAC9H,uBAAuB;AACvB,wBAAwB;AACxB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,yFAAyF,0BAA0B;AACnH,iBAAiB;AACjB;AACA,qFAAqF,gBAAgB;AACrG;AACA,qFAAqF,gBAAgB;AACrG;AACA,SAAS;AACT;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kHAAkH,kCAAkC,EAAE;AACtJ;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4FAA4F,uBAAuB,EAAE;AACrH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACrhBa;AACb;AACA;AACA,gDAAgD,OAAO;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,+DAA+D,gBAAgB,EAAE,EAAE;AAC9G;AACA,mCAAmC,MAAM,6BAA6B,EAAE,YAAY,WAAW,EAAE;AACjG,kCAAkC,MAAM,iCAAiC,EAAE,YAAY,WAAW,EAAE;AACpG,+BAA+B,qFAAqF;AACpH;AACA,KAAK;AACL;AACA;AACA,aAAa,6BAA6B,0BAA0B,aAAa,EAAE,qBAAqB;AACxG,gBAAgB,qDAAqD,oEAAoE,aAAa,EAAE;AACxJ,sBAAsB,sBAAsB,qBAAqB,GAAG;AACpE;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC,kCAAkC,SAAS;AAC3C,kCAAkC,WAAW,UAAU;AACvD,yCAAyC,cAAc;AACvD;AACA,6GAA6G,OAAO,UAAU;AAC9H,gFAAgF,iBAAiB,OAAO;AACxG,wDAAwD,gBAAgB,QAAQ,OAAO;AACvF,8CAA8C,gBAAgB,gBAAgB,OAAO;AACrF;AACA,iCAAiC;AACjC;AACA;AACA,SAAS,YAAY,aAAa,OAAO,EAAE,UAAU,WAAW;AAChE,mCAAmC,SAAS;AAC5C;AACA;AACA,8CAA8C,cAAc;AAC5D,uBAAuB,mBAAO,CAAC,yDAAsB;AACrD,yBAAyB,mBAAO,CAAC,6DAAwB;AACzD,mBAAmB,mBAAO,CAAC,yCAAc;AACzC,cAAc,mBAAO,CAAC,uCAAa;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,kDAAkD,EAAE;AAChH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,0DAA0D;AAC1D,6BAA6B,uBAAuB;AACpD,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA,kFAAkF,2CAA2C,EAAE;AAC/H;AACA;AACA,6BAA6B;AAC7B,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AClSa;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA,yBAAyB,mBAAO,CAAC,yDAAoB;AACrD;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACnCa;AACb;AACA;AACA,gDAAgD,OAAO;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA,gCAAgC,wFAAwF;AACxH;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;;;;;;;;;;;;ACpEa;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA","file":"idb-managed.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"IDBM\"] = factory();\n\telse\n\t\troot[\"IDBM\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"./\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","const instanceOfAny = (object, constructors) => constructors.some(c => object instanceof c);\n\nlet idbProxyableTypes;\r\nlet cursorAdvanceMethods;\r\n// This is a function to prevent it throwing up in node environments.\r\nfunction getIdbProxyableTypes() {\r\n    return (idbProxyableTypes ||\r\n        (idbProxyableTypes = [\r\n            IDBDatabase,\r\n            IDBObjectStore,\r\n            IDBIndex,\r\n            IDBCursor,\r\n            IDBTransaction,\r\n        ]));\r\n}\r\n// This is a function to prevent it throwing up in node environments.\r\nfunction getCursorAdvanceMethods() {\r\n    return (cursorAdvanceMethods ||\r\n        (cursorAdvanceMethods = [\r\n            IDBCursor.prototype.advance,\r\n            IDBCursor.prototype.continue,\r\n            IDBCursor.prototype.continuePrimaryKey,\r\n        ]));\r\n}\r\nconst cursorRequestMap = new WeakMap();\r\nconst transactionDoneMap = new WeakMap();\r\nconst transactionStoreNamesMap = new WeakMap();\r\nconst transformCache = new WeakMap();\r\nconst reverseTransformCache = new WeakMap();\r\nfunction promisifyRequest(request) {\r\n    const promise = new Promise((resolve, reject) => {\r\n        const unlisten = () => {\r\n            request.removeEventListener('success', success);\r\n            request.removeEventListener('error', error);\r\n        };\r\n        const success = () => {\r\n            resolve(wrap(request.result));\r\n            unlisten();\r\n        };\r\n        const error = () => {\r\n            reject(request.error);\r\n            unlisten();\r\n        };\r\n        request.addEventListener('success', success);\r\n        request.addEventListener('error', error);\r\n    });\r\n    promise\r\n        .then(value => {\r\n        // Since cursoring reuses the IDBRequest (*sigh*), we cache it for later retrieval\r\n        // (see wrapFunction).\r\n        if (value instanceof IDBCursor) {\r\n            cursorRequestMap.set(value, request);\r\n        }\r\n        // Catching to avoid \"Uncaught Promise exceptions\"\r\n    })\r\n        .catch(() => { });\r\n    // This mapping exists in reverseTransformCache but doesn't doesn't exist in transformCache. This\r\n    // is because we create many promises from a single IDBRequest.\r\n    reverseTransformCache.set(promise, request);\r\n    return promise;\r\n}\r\nfunction cacheDonePromiseForTransaction(tx) {\r\n    // Early bail if we've already created a done promise for this transaction.\r\n    if (transactionDoneMap.has(tx))\r\n        return;\r\n    const done = new Promise((resolve, reject) => {\r\n        const unlisten = () => {\r\n            tx.removeEventListener('complete', complete);\r\n            tx.removeEventListener('error', error);\r\n            tx.removeEventListener('abort', error);\r\n        };\r\n        const complete = () => {\r\n            resolve();\r\n            unlisten();\r\n        };\r\n        const error = () => {\r\n            reject(tx.error);\r\n            unlisten();\r\n        };\r\n        tx.addEventListener('complete', complete);\r\n        tx.addEventListener('error', error);\r\n        tx.addEventListener('abort', error);\r\n    });\r\n    // Cache it for later retrieval.\r\n    transactionDoneMap.set(tx, done);\r\n}\r\nlet idbProxyTraps = {\r\n    get(target, prop, receiver) {\r\n        if (target instanceof IDBTransaction) {\r\n            // Special handling for transaction.done.\r\n            if (prop === 'done')\r\n                return transactionDoneMap.get(target);\r\n            // Polyfill for objectStoreNames because of Edge.\r\n            if (prop === 'objectStoreNames') {\r\n                return target.objectStoreNames || transactionStoreNamesMap.get(target);\r\n            }\r\n            // Make tx.store return the only store in the transaction, or undefined if there are many.\r\n            if (prop === 'store') {\r\n                return receiver.objectStoreNames[1]\r\n                    ? undefined\r\n                    : receiver.objectStore(receiver.objectStoreNames[0]);\r\n            }\r\n        }\r\n        // Else transform whatever we get back.\r\n        return wrap(target[prop]);\r\n    },\r\n    has(target, prop) {\r\n        if (target instanceof IDBTransaction &&\r\n            (prop === 'done' || prop === 'store')) {\r\n            return true;\r\n        }\r\n        return prop in target;\r\n    },\r\n};\r\nfunction addTraps(callback) {\r\n    idbProxyTraps = callback(idbProxyTraps);\r\n}\r\nfunction wrapFunction(func) {\r\n    // Due to expected object equality (which is enforced by the caching in `wrap`), we\r\n    // only create one new func per func.\r\n    // Edge doesn't support objectStoreNames (booo), so we polyfill it here.\r\n    if (func === IDBDatabase.prototype.transaction &&\r\n        !('objectStoreNames' in IDBTransaction.prototype)) {\r\n        return function (storeNames, ...args) {\r\n            const tx = func.call(unwrap(this), storeNames, ...args);\r\n            transactionStoreNamesMap.set(tx, storeNames.sort ? storeNames.sort() : [storeNames]);\r\n            return wrap(tx);\r\n        };\r\n    }\r\n    // Cursor methods are special, as the behaviour is a little more different to standard IDB. In\r\n    // IDB, you advance the cursor and wait for a new 'success' on the IDBRequest that gave you the\r\n    // cursor. It's kinda like a promise that can resolve with many values. That doesn't make sense\r\n    // with real promises, so each advance methods returns a new promise for the cursor object, or\r\n    // undefined if the end of the cursor has been reached.\r\n    if (getCursorAdvanceMethods().includes(func)) {\r\n        return function (...args) {\r\n            // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\r\n            // the original object.\r\n            func.apply(unwrap(this), args);\r\n            return wrap(cursorRequestMap.get(this));\r\n        };\r\n    }\r\n    return function (...args) {\r\n        // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\r\n        // the original object.\r\n        return wrap(func.apply(unwrap(this), args));\r\n    };\r\n}\r\nfunction transformCachableValue(value) {\r\n    if (typeof value === 'function')\r\n        return wrapFunction(value);\r\n    // This doesn't return, it just creates a 'done' promise for the transaction,\r\n    // which is later returned for transaction.done (see idbObjectHandler).\r\n    if (value instanceof IDBTransaction)\r\n        cacheDonePromiseForTransaction(value);\r\n    if (instanceOfAny(value, getIdbProxyableTypes()))\r\n        return new Proxy(value, idbProxyTraps);\r\n    // Return the same value back if we're not going to transform it.\r\n    return value;\r\n}\r\nfunction wrap(value) {\r\n    // We sometimes generate multiple promises from a single IDBRequest (eg when cursoring), because\r\n    // IDB is weird and a single IDBRequest can yield many responses, so these can't be cached.\r\n    if (value instanceof IDBRequest)\r\n        return promisifyRequest(value);\r\n    // If we've already transformed this value before, reuse the transformed value.\r\n    // This is faster, but it also provides object equality.\r\n    if (transformCache.has(value))\r\n        return transformCache.get(value);\r\n    const newValue = transformCachableValue(value);\r\n    // Not all types are transformed.\r\n    // These may be primitive types, so they can't be WeakMap keys.\r\n    if (newValue !== value) {\r\n        transformCache.set(value, newValue);\r\n        reverseTransformCache.set(newValue, value);\r\n    }\r\n    return newValue;\r\n}\r\nconst unwrap = (value) => reverseTransformCache.get(value);\n\nexport { wrap as a, addTraps as b, instanceOfAny as c, reverseTransformCache as d, unwrap as e };\n","import { a as wrap, b as addTraps } from './chunk.js';\nexport { e as unwrap, a as wrap } from './chunk.js';\n\n/**\r\n * Open a database.\r\n *\r\n * @param name Name of the database.\r\n * @param version Schema version.\r\n * @param callbacks Additional callbacks.\r\n */\r\nfunction openDB(name, version, { blocked, upgrade, blocking } = {}) {\r\n    const request = indexedDB.open(name, version);\r\n    const openPromise = wrap(request);\r\n    if (upgrade) {\r\n        request.addEventListener('upgradeneeded', event => {\r\n            upgrade(wrap(request.result), event.oldVersion, event.newVersion, wrap(request.transaction));\r\n        });\r\n    }\r\n    if (blocked)\r\n        request.addEventListener('blocked', () => blocked());\r\n    if (blocking) {\r\n        openPromise.then(db => db.addEventListener('versionchange', blocking)).catch(() => { });\r\n    }\r\n    return openPromise;\r\n}\r\n/**\r\n * Delete a database.\r\n *\r\n * @param name Name of the database.\r\n */\r\nfunction deleteDB(name, { blocked } = {}) {\r\n    const request = indexedDB.deleteDatabase(name);\r\n    if (blocked)\r\n        request.addEventListener('blocked', () => blocked());\r\n    return wrap(request).then(() => undefined);\r\n}\n\nconst readMethods = ['get', 'getKey', 'getAll', 'getAllKeys', 'count'];\r\nconst writeMethods = ['put', 'add', 'delete', 'clear'];\r\nconst cachedMethods = new Map();\r\nfunction getMethod(target, prop) {\r\n    if (!(target instanceof IDBDatabase &&\r\n        !(prop in target) &&\r\n        typeof prop === 'string')) {\r\n        return;\r\n    }\r\n    if (cachedMethods.get(prop))\r\n        return cachedMethods.get(prop);\r\n    const targetFuncName = prop.replace(/FromIndex$/, '');\r\n    const useIndex = prop !== targetFuncName;\r\n    const isWrite = writeMethods.includes(targetFuncName);\r\n    if (\r\n    // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.\r\n    !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) ||\r\n        !(isWrite || readMethods.includes(targetFuncName))) {\r\n        return;\r\n    }\r\n    const method = async function (storeName, ...args) {\r\n        // isWrite ? 'readwrite' : undefined gzipps better, but fails in Edge :(\r\n        const tx = this.transaction(storeName, isWrite ? 'readwrite' : 'readonly');\r\n        let target = tx.store;\r\n        if (useIndex)\r\n            target = target.index(args.shift());\r\n        const returnVal = target[targetFuncName](...args);\r\n        if (isWrite)\r\n            await tx.done;\r\n        return returnVal;\r\n    };\r\n    cachedMethods.set(prop, method);\r\n    return method;\r\n}\r\naddTraps(oldTraps => ({\r\n    get: (target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver),\r\n    has: (target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop),\r\n}));\n\nexport { openDB, deleteDB };\n","\"use strict\";\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar idb_1 = require(\"idb\");\nvar utils_1 = require(\"./lib/utils\");\nvar formatted_result_1 = require(\"./lib/formatted_result\");\nvar IDB_MANAGER_VERSION = 1;\nvar IDB_MANAGER_DB_NAME = 'IDB_MANAGER_DB';\nvar IDB_MANAGER_DB_TABLE_NAME = 'IDB_MANAGER_STORE';\nvar IDB_MANAGER_DB_TABLE_INDEX_NAME = 'dbName';\nvar UPDATETIME_KEYNAME = 'updateTime';\nvar EXPIRETIME_KEYNAME = 'expireTime';\nfunction indexRange2DBKey(indexRange) {\n    var onlyIndex = indexRange.onlyIndex, lowerIndex = indexRange.lowerIndex, upperIndex = indexRange.upperIndex, _a = indexRange.lowerExclusive, lowerExclusive = _a === void 0 ? false : _a, _b = indexRange.upperExclusive, upperExclusive = _b === void 0 ? false : _b;\n    if (onlyIndex !== undefined) {\n        return IDBKeyRange.only(onlyIndex);\n    }\n    else if (lowerIndex !== undefined && upperIndex !== undefined) {\n        return IDBKeyRange.bound(lowerIndex, upperIndex, lowerExclusive, upperExclusive);\n    }\n    else if (lowerIndex !== undefined) {\n        return IDBKeyRange.lowerBound(lowerIndex, lowerExclusive);\n    }\n    else {\n        return IDBKeyRange.upperBound(upperIndex, upperExclusive);\n    }\n}\nfunction itemWrapper(itemConfig) {\n    var _a;\n    var currentTime = Date.now();\n    return __assign(__assign({}, itemConfig.item), (_a = {},\n        _a[UPDATETIME_KEYNAME] = currentTime,\n        _a[EXPIRETIME_KEYNAME] = itemConfig.itemDuration !== undefined\n            ? itemConfig.itemDuration + currentTime\n            : -1,\n        _a));\n}\nfunction itemUnwrapper(item) {\n    if (!item) {\n        return null;\n    }\n    else if (item.expireTime > 0 && item.expireTime < Date.now()) {\n        return null;\n    }\n    else {\n        delete item.updateTime;\n        delete item.expireTime;\n        return item;\n    }\n}\nfunction registerDBInManager(dbInfo) {\n    return __awaiter(this, void 0, void 0, function () {\n        var dbManager, dbAlreadyInManager, addDBTrans, table, dbItem;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0: return [4 /*yield*/, openDBManager()];\n                case 1:\n                    dbManager = _a.sent();\n                    return [4 /*yield*/, getItemFromDB(dbManager, IDB_MANAGER_DB_TABLE_NAME, dbInfo.name)];\n                case 2:\n                    dbAlreadyInManager = (_a.sent());\n                    if (!(dbAlreadyInManager && dbInfo.version <= dbAlreadyInManager.version)) return [3 /*break*/, 3];\n                    // No need to register\n                    return [2 /*return*/];\n                case 3:\n                    addDBTrans = dbManager.transaction(IDB_MANAGER_DB_TABLE_NAME, 'readwrite');\n                    table = addDBTrans.objectStore(IDB_MANAGER_DB_TABLE_NAME);\n                    dbItem = {\n                        dbName: dbInfo.name,\n                        tableList: dbInfo.tableList,\n                        version: dbInfo.version\n                    };\n                    table.put(itemWrapper({\n                        item: dbItem,\n                        tableName: IDB_MANAGER_DB_TABLE_NAME\n                    }));\n                    return [4 /*yield*/, addDBTrans.done];\n                case 4:\n                    _a.sent();\n                    dbManager.close();\n                    _a.label = 5;\n                case 5: return [2 /*return*/];\n            }\n        });\n    });\n}\nfunction unregisterDBInManager(dbName) {\n    return __awaiter(this, void 0, void 0, function () {\n        var dbManager, deleteTrans, table;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0: return [4 /*yield*/, openDBManager()];\n                case 1:\n                    dbManager = _a.sent();\n                    deleteTrans = dbManager.transaction(IDB_MANAGER_DB_TABLE_NAME, 'readwrite');\n                    table = deleteTrans.objectStore(IDB_MANAGER_DB_TABLE_NAME);\n                    table.delete(dbName);\n                    return [4 /*yield*/, deleteTrans.done];\n                case 2:\n                    _a.sent();\n                    dbManager.close();\n                    return [2 /*return*/];\n            }\n        });\n    });\n}\nfunction createDB(dbInfo) {\n    return __awaiter(this, void 0, void 0, function () {\n        var db;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0: return [4 /*yield*/, registerDBInManager(dbInfo)];\n                case 1:\n                    _a.sent();\n                    return [4 /*yield*/, idb_1.openDB(dbInfo.name, dbInfo.version, {\n                            upgrade: function (upgradeDB, oldVersion, newVersion, transaction) {\n                                upgradeDBWithTableList(upgradeDB, dbInfo.tableList, transaction);\n                            }\n                        })];\n                case 2:\n                    db = _a.sent();\n                    return [2 /*return*/, db];\n            }\n        });\n    });\n}\nfunction openDBManager() {\n    return __awaiter(this, void 0, void 0, function () {\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0: return [4 /*yield*/, idb_1.openDB(IDB_MANAGER_DB_NAME, IDB_MANAGER_VERSION, {\n                        // In case DB Manager has not been created.\n                        upgrade: function (upgradeDB) {\n                            upgradeDBManager(upgradeDB);\n                        }\n                    })];\n                case 1: return [2 /*return*/, _a.sent()];\n            }\n        });\n    });\n}\nfunction openDB(dbName) {\n    return __awaiter(this, void 0, void 0, function () {\n        var dbManager, dbAlreadyInManager, db;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0: return [4 /*yield*/, openDBManager()];\n                case 1:\n                    dbManager = _a.sent();\n                    return [4 /*yield*/, getItemFromDB(dbManager, IDB_MANAGER_DB_TABLE_NAME, dbName)];\n                case 2:\n                    dbAlreadyInManager = (_a.sent());\n                    dbManager.close();\n                    if (!dbAlreadyInManager) return [3 /*break*/, 4];\n                    return [4 /*yield*/, idb_1.openDB(dbAlreadyInManager.dbName, dbAlreadyInManager.version, {\n                            // In case this DB has not been created.\n                            upgrade: function (upgradeDB, oldVersion, newVersion, transaction) {\n                                upgradeDBWithTableList(upgradeDB, dbAlreadyInManager.tableList || [], transaction);\n                            }\n                        })];\n                case 3:\n                    db = _a.sent();\n                    return [2 /*return*/, db];\n                case 4: throw formatted_result_1.default['DB_NOT_FOUND'];\n            }\n        });\n    });\n}\nfunction getItemFromDB(db, tableName, primaryKeyValue) {\n    return __awaiter(this, void 0, void 0, function () {\n        var trans, table, itemInTable;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    if (!db.objectStoreNames.contains(tableName)) return [3 /*break*/, 2];\n                    trans = db.transaction(tableName, 'readonly');\n                    table = trans.objectStore(tableName);\n                    return [4 /*yield*/, table.get(primaryKeyValue)];\n                case 1:\n                    itemInTable = (_a.sent());\n                    return [2 /*return*/, itemUnwrapper(itemInTable)];\n                case 2: throw formatted_result_1.default['TABLE_NOT_FOUND'];\n            }\n        });\n    });\n}\nfunction upgradeDBManager(upgradeDB) {\n    upgradeDB.createObjectStore(IDB_MANAGER_DB_TABLE_NAME, {\n        keyPath: IDB_MANAGER_DB_TABLE_INDEX_NAME\n    });\n}\nfunction upgradeDBWithTableList(upgradeDB, tableList, transaction) {\n    try {\n        tableList.forEach(function (tableConfig) {\n            // If table already exists.\n            if (upgradeDB.objectStoreNames.contains(tableConfig.tableName)) {\n                var currentTable_1 = transaction.objectStore(tableConfig.tableName);\n                // Create new index for present table.\n                (tableConfig.indexList || []).forEach(function (theIndex) {\n                    if (!currentTable_1.indexNames.contains(theIndex.indexName)) {\n                        currentTable_1.createIndex(theIndex.indexName, theIndex.indexName, { unique: theIndex.unique });\n                    }\n                });\n                // Else create new table.\n            }\n            else {\n                var tablePrimaryKey = tableConfig.primaryKey || 'id';\n                var tableToCreate_1 = upgradeDB.createObjectStore(tableConfig.tableName, __assign({ keyPath: tablePrimaryKey }, (tablePrimaryKey === 'id'\n                    ? { autoIncrement: true }\n                    : {})));\n                // Set index of primaryKey.\n                tableToCreate_1.createIndex(tablePrimaryKey, tablePrimaryKey, {\n                    unique: true\n                });\n                // Set indexes defined in tableConfig\n                (tableConfig.indexList || []).forEach(function (theIndex) {\n                    tableToCreate_1.createIndex(theIndex.indexName, theIndex.indexName, { unique: theIndex.unique });\n                });\n                // Set index of updateTime for data ordering priority.\n                tableToCreate_1.createIndex(UPDATETIME_KEYNAME, UPDATETIME_KEYNAME, { unique: false });\n                // Set index of expireTime for expired data deletion.\n                tableToCreate_1.createIndex(EXPIRETIME_KEYNAME, EXPIRETIME_KEYNAME, { unique: false });\n            }\n        });\n    }\n    catch (e) {\n        console.log(e);\n        upgradeDB.close(); // Close upgraded DB to trigger the failure of this opening process.\n    }\n}\nfunction deleteItemsFromDB(db, tableIndexRanges) {\n    return __awaiter(this, void 0, void 0, function () {\n        var dedupTableNameList, deleteItemsTrans, _i, tableIndexRanges_1, tableIndexRange, tableName, indexRange, table, index, cursor, errMsg_1, e_1;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    dedupTableNameList = utils_1.deduplicateList(tableIndexRanges.map(function (tableIndexRange) { return tableIndexRange.tableName; }));\n                    dedupTableNameList.forEach(function (tableName) {\n                        if (!db.objectStoreNames.contains(tableName)) {\n                            throw formatted_result_1.default['TABLE_NOT_FOUND'];\n                        }\n                    });\n                    deleteItemsTrans = db.transaction(dedupTableNameList, 'readwrite');\n                    _a.label = 1;\n                case 1:\n                    _a.trys.push([1, 11, , 16]);\n                    _i = 0, tableIndexRanges_1 = tableIndexRanges;\n                    _a.label = 2;\n                case 2:\n                    if (!(_i < tableIndexRanges_1.length)) return [3 /*break*/, 9];\n                    tableIndexRange = tableIndexRanges_1[_i];\n                    tableName = tableIndexRange.tableName, indexRange = tableIndexRange.indexRange;\n                    table = deleteItemsTrans.objectStore(tableName);\n                    if (!!indexRange) return [3 /*break*/, 4];\n                    return [4 /*yield*/, table.clear()];\n                case 3:\n                    _a.sent();\n                    return [3 /*break*/, 8];\n                case 4:\n                    index = table.index(indexRange.indexName);\n                    return [4 /*yield*/, index.openCursor(indexRange2DBKey(indexRange))];\n                case 5:\n                    cursor = _a.sent();\n                    _a.label = 6;\n                case 6:\n                    if (!cursor) return [3 /*break*/, 8];\n                    table.delete(cursor.primaryKey);\n                    return [4 /*yield*/, cursor.continue()];\n                case 7:\n                    cursor = _a.sent();\n                    return [3 /*break*/, 6];\n                case 8:\n                    _i++;\n                    return [3 /*break*/, 2];\n                case 9: return [4 /*yield*/, deleteItemsTrans.done];\n                case 10:\n                    _a.sent();\n                    db.close();\n                    return [3 /*break*/, 16];\n                case 11:\n                    errMsg_1 = _a.sent();\n                    db.close();\n                    // Abort transaction manually to keep deleteItems operation atomic.\n                    try {\n                        deleteItemsTrans.abort();\n                    }\n                    catch (e) {\n                        // Do nothing if transaction abort failed.\n                    }\n                    _a.label = 12;\n                case 12:\n                    _a.trys.push([12, 14, , 15]);\n                    // Catch the Promise error caused by transaction abortion\n                    return [4 /*yield*/, deleteItemsTrans.done];\n                case 13:\n                    // Catch the Promise error caused by transaction abortion\n                    _a.sent();\n                    return [3 /*break*/, 15];\n                case 14:\n                    e_1 = _a.sent();\n                    throw errMsg_1;\n                case 15: return [3 /*break*/, 16];\n                case 16: return [2 /*return*/];\n            }\n        });\n    });\n}\nfunction addItems(customDB, items) {\n    return __awaiter(this, void 0, void 0, function () {\n        var db, dedupTableNameList, addItemsTrans, errMsg_2, e_2;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0: return [4 /*yield*/, createDB(customDB)];\n                case 1:\n                    db = _a.sent();\n                    dedupTableNameList = utils_1.deduplicateList(items.map(function (item) { return item.tableName; }));\n                    addItemsTrans = db.transaction(dedupTableNameList, 'readwrite');\n                    _a.label = 2;\n                case 2:\n                    _a.trys.push([2, 4, , 9]);\n                    items.forEach(function (item) {\n                        var table = addItemsTrans.objectStore(item.tableName);\n                        table.put(itemWrapper(item));\n                    });\n                    return [4 /*yield*/, addItemsTrans.done];\n                case 3:\n                    _a.sent();\n                    db.close();\n                    return [3 /*break*/, 9];\n                case 4:\n                    errMsg_2 = _a.sent();\n                    db.close();\n                    // Abort transaction manually to keep addItems operation atomic.\n                    try {\n                        addItemsTrans.abort();\n                    }\n                    catch (e) {\n                        // Do nothing if transaction abort failed.\n                    }\n                    _a.label = 5;\n                case 5:\n                    _a.trys.push([5, 7, , 8]);\n                    // Catch the Promise error caused by transaction abortion.\n                    return [4 /*yield*/, addItemsTrans.done];\n                case 6:\n                    // Catch the Promise error caused by transaction abortion.\n                    _a.sent();\n                    return [3 /*break*/, 8];\n                case 7:\n                    e_2 = _a.sent();\n                    throw errMsg_2;\n                case 8: return [3 /*break*/, 9];\n                case 9: return [2 /*return*/];\n            }\n        });\n    });\n}\nexports.addItems = addItems;\nfunction getItem(dbName, tableName, primaryKeyValue) {\n    return __awaiter(this, void 0, void 0, function () {\n        var db, item, e_3;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0: return [4 /*yield*/, openDB(dbName)];\n                case 1:\n                    db = _a.sent();\n                    _a.label = 2;\n                case 2:\n                    _a.trys.push([2, 4, , 5]);\n                    return [4 /*yield*/, getItemFromDB(db, tableName, primaryKeyValue)];\n                case 3:\n                    item = _a.sent();\n                    db.close();\n                    return [2 /*return*/, item];\n                case 4:\n                    e_3 = _a.sent();\n                    db.close();\n                    throw e_3;\n                case 5: return [2 /*return*/];\n            }\n        });\n    });\n}\nexports.getItem = getItem;\nfunction getItemsInRange(dbName, tableIndexRange) {\n    return __awaiter(this, void 0, void 0, function () {\n        var tableName, indexRange, db, trans, table, items, wrappedItems, index, cursor, e_4;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    tableName = tableIndexRange.tableName, indexRange = tableIndexRange.indexRange;\n                    return [4 /*yield*/, openDB(dbName)];\n                case 1:\n                    db = _a.sent();\n                    _a.label = 2;\n                case 2:\n                    _a.trys.push([2, 9, , 10]);\n                    if (!db.objectStoreNames.contains(tableName)) {\n                        throw formatted_result_1.default['TABLE_NOT_FOUND'];\n                    }\n                    trans = db.transaction(tableName, 'readonly');\n                    table = trans.objectStore(tableName);\n                    items = [];\n                    if (!!indexRange) return [3 /*break*/, 4];\n                    return [4 /*yield*/, table.getAll()];\n                case 3:\n                    wrappedItems = _a.sent();\n                    items = (wrappedItems || []).map(itemUnwrapper);\n                    return [3 /*break*/, 8];\n                case 4:\n                    index = table.index(indexRange.indexName);\n                    return [4 /*yield*/, index.openCursor(indexRange2DBKey(indexRange))];\n                case 5:\n                    cursor = _a.sent();\n                    _a.label = 6;\n                case 6:\n                    if (!cursor) return [3 /*break*/, 8];\n                    items.push(itemUnwrapper(cursor.value));\n                    return [4 /*yield*/, cursor.continue()];\n                case 7:\n                    cursor = _a.sent();\n                    return [3 /*break*/, 6];\n                case 8:\n                    db.close();\n                    return [2 /*return*/, items];\n                case 9:\n                    e_4 = _a.sent();\n                    db.close();\n                    throw e_4;\n                case 10: return [2 /*return*/];\n            }\n        });\n    });\n}\nexports.getItemsInRange = getItemsInRange;\nfunction deleteDB(dbName) {\n    return __awaiter(this, void 0, void 0, function () {\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0: return [4 /*yield*/, unregisterDBInManager(dbName)];\n                case 1:\n                    _a.sent();\n                    return [4 /*yield*/, idb_1.deleteDB(dbName)];\n                case 2:\n                    _a.sent();\n                    return [2 /*return*/];\n            }\n        });\n    });\n}\nexports.deleteDB = deleteDB;\nfunction deleteItems(dbName, tableIndexRanges) {\n    return __awaiter(this, void 0, void 0, function () {\n        var db, e_5;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    _a.trys.push([0, 3, , 4]);\n                    return [4 /*yield*/, openDB(dbName)];\n                case 1:\n                    db = _a.sent();\n                    return [4 /*yield*/, deleteItemsFromDB(db, tableIndexRanges)];\n                case 2:\n                    _a.sent();\n                    return [3 /*break*/, 4];\n                case 3:\n                    e_5 = _a.sent();\n                    if (e_5.msg === formatted_result_1.default.DB_NOT_FOUND.msg || e_5.msg === formatted_result_1.default.TABLE_NOT_FOUND.msg) {\n                        // If db or table does not exist, no need to deleteItems at all.\n                        return [2 /*return*/];\n                    }\n                    else {\n                        throw e_5;\n                    }\n                    return [3 /*break*/, 4];\n                case 4: return [2 /*return*/];\n            }\n        });\n    });\n}\nexports.deleteItems = deleteItems;\nexports.default = {\n    addItems: addItems,\n    getItem: getItem,\n    getItemsInRange: getItemsInRange,\n    deleteDB: deleteDB,\n    deleteItems: deleteItems\n};\n","\"use strict\";\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar db_env_checker_1 = require(\"./lib/db_env_checker\");\nvar formatted_result_1 = require(\"./lib/formatted_result\");\nvar db_wrapper_1 = require(\"./db_wrapper\");\nvar utils_1 = require(\"./lib/utils\");\nvar DEFAULT_DB_VERSION = 1;\nvar OPTIONAL = true;\nfunction _customDBConfigChecker(dbConfig) {\n    utils_1.paramChecker(dbConfig, utils_1.ParamCheckerEnum.NotNullObject, 'dbConfig', !OPTIONAL);\n    utils_1.paramChecker(dbConfig.dbName, utils_1.ParamCheckerEnum.String, 'dbName', !OPTIONAL);\n    utils_1.paramChecker(dbConfig.dbVersion, utils_1.ParamCheckerEnum.NonNegativeInteger, 'dbVersion', OPTIONAL);\n    utils_1.paramChecker(dbConfig.itemDuration, utils_1.ParamCheckerEnum.NonNegativeInteger, 'itemDuration of dbConfig', OPTIONAL);\n    utils_1.paramChecker(dbConfig.tables, utils_1.ParamCheckerEnum.NotNullObject, 'tables', OPTIONAL);\n    Object.keys(dbConfig.tables || {}).forEach(function (tableName) {\n        var tableConfig = dbConfig.tables[tableName];\n        utils_1.paramChecker(tableConfig.primaryKey, utils_1.ParamCheckerEnum.String, 'primaryKey', OPTIONAL);\n        utils_1.paramChecker(tableConfig.itemDuration, utils_1.ParamCheckerEnum.NonNegativeInteger, 'itemDuration of table', OPTIONAL);\n        utils_1.paramChecker(tableConfig.indexList, utils_1.ParamCheckerEnum.Array, 'indexList', OPTIONAL);\n        (tableConfig.indexList || []).forEach(function (index) {\n            utils_1.paramChecker(index.indexName, utils_1.ParamCheckerEnum.String, 'indexName', !OPTIONAL);\n            utils_1.paramChecker(index.unique, utils_1.ParamCheckerEnum.Boolean, 'unique', OPTIONAL);\n        });\n    });\n}\nfunction _customDBAddItemsParamChecker(items, tableListInDB) {\n    utils_1.paramChecker(items, utils_1.ParamCheckerEnum.Array, 'items', !OPTIONAL);\n    items.forEach(function (itemOfTable) {\n        utils_1.paramChecker(itemOfTable.tableName, utils_1.ParamCheckerEnum.String, \"item's tableName\", !OPTIONAL);\n        utils_1.paramChecker(itemOfTable.itemDuration, utils_1.ParamCheckerEnum.NonNegativeInteger, \"item's itemDuration\", OPTIONAL);\n        var theTable = tableListInDB.find(function (table) { return table.tableName === itemOfTable.tableName; });\n        if (!theTable) {\n            throw \"Table \" + itemOfTable.tableName + \" does not exist\";\n        }\n        else if (theTable.primaryKey !== undefined &&\n            Object.getOwnPropertyNames(itemOfTable.item).indexOf(theTable.primaryKey) < 0) {\n            throw \"primaryKey is needed for item in table \" + itemOfTable.tableName;\n        }\n    });\n}\nfunction tableIndexRangeParamChecker(tableIndexRange) {\n    utils_1.paramChecker(tableIndexRange, utils_1.ParamCheckerEnum.NotNullObject, 'tableIndexRange', !OPTIONAL);\n    utils_1.paramChecker(tableIndexRange.tableName, utils_1.ParamCheckerEnum.String, \"tableIndexRange's\", !OPTIONAL);\n    utils_1.paramChecker(tableIndexRange.indexRange, utils_1.ParamCheckerEnum.NotNullObject, \"tableIndexRange's indexRange\", OPTIONAL);\n    if (tableIndexRange.indexRange) {\n        var _a = tableIndexRange.indexRange, indexName = _a.indexName, lowerExclusive = _a.lowerExclusive, upperExclusive = _a.upperExclusive;\n        utils_1.paramChecker(indexName, utils_1.ParamCheckerEnum.String, \"indexRange's indexName\", !OPTIONAL);\n        utils_1.paramChecker(lowerExclusive, utils_1.ParamCheckerEnum.Boolean, \"indexRange's lowerExclusive\", OPTIONAL);\n        utils_1.paramChecker(upperExclusive, utils_1.ParamCheckerEnum.Boolean, \"indexRange's upperExclusive\", OPTIONAL);\n    }\n}\nfunction idbIsSupported() {\n    var supportResult = db_env_checker_1.default.getResult();\n    return supportResult !== formatted_result_1.default['DB_NOT_SUPPORT'];\n}\nexports.idbIsSupported = idbIsSupported;\nvar CustomDB = /** @class */ (function () {\n    function CustomDB(dbConfig) {\n        try {\n            _customDBConfigChecker(dbConfig);\n        }\n        catch (errMsg) {\n            throw formatted_result_1.default['PARAM_INVALID'].setData({\n                desc: \"\" + errMsg\n            });\n        }\n        this.name = dbConfig.dbName;\n        this.version = utils_1.optionWithBackup(dbConfig.dbVersion, DEFAULT_DB_VERSION);\n        this.tableList = Object.keys(dbConfig.tables || {}).map(function (tableName) {\n            return __assign({ tableName: tableName }, dbConfig.tables[tableName]);\n        });\n        this.itemDuration = dbConfig.itemDuration;\n    }\n    CustomDB.prototype.addItems = function (items) {\n        return __awaiter(this, void 0, void 0, function () {\n            var itemDurationOverrider, itemsWithDuration, e_1;\n            var _this = this;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        itemDurationOverrider = function (ofDB, ofTable, ofItem) {\n                            if (ofItem !== undefined) {\n                                return ofItem;\n                            }\n                            else if (ofTable !== undefined) {\n                                return ofTable;\n                            }\n                            else {\n                                return ofDB;\n                            }\n                        };\n                        try {\n                            _customDBAddItemsParamChecker(items, this.tableList);\n                        }\n                        catch (errMsg) {\n                            throw formatted_result_1.default['PARAM_INVALID'].setData({\n                                desc: \"\" + errMsg\n                            });\n                        }\n                        _a.label = 1;\n                    case 1:\n                        _a.trys.push([1, 3, , 4]);\n                        itemsWithDuration = items.map(function (item) {\n                            var theTable = _this.tableList.find(function (table) { return table.tableName === item.tableName; });\n                            return __assign({\n                                itemDuration: itemDurationOverrider(_this.itemDuration, theTable.itemDuration, item.itemDuration)\n                            }, item);\n                        });\n                        return [4 /*yield*/, db_wrapper_1.default.addItems(this, itemsWithDuration)];\n                    case 2:\n                        _a.sent();\n                        return [2 /*return*/, formatted_result_1.default['SUCC']];\n                    case 3:\n                        e_1 = _a.sent();\n                        throw formatted_result_1.default['ADD_ITEMS_FAIL'].setData({\n                            desc: \"\" + e_1\n                        });\n                    case 4: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    CustomDB.prototype.getItem = function (tableName, primaryKeyValue) {\n        return __awaiter(this, void 0, void 0, function () {\n            var e_2;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        _a.trys.push([0, 2, , 3]);\n                        return [4 /*yield*/, db_wrapper_1.default.getItem(this.name, tableName, primaryKeyValue)];\n                    case 1: return [2 /*return*/, _a.sent()];\n                    case 2:\n                        e_2 = _a.sent();\n                        throw formatted_result_1.default['GET_ITEM_FAIL'].setData({\n                            desc: \"\" + e_2\n                        });\n                    case 3: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    CustomDB.prototype.getItemsInRange = function (tableIndexRange) {\n        return __awaiter(this, void 0, void 0, function () {\n            var e_3;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        try {\n                            tableIndexRangeParamChecker(tableIndexRange);\n                        }\n                        catch (errMsg) {\n                            throw formatted_result_1.default['PARAM_INVALID'].setData({\n                                desc: \"\" + errMsg\n                            });\n                        }\n                        _a.label = 1;\n                    case 1:\n                        _a.trys.push([1, 3, , 4]);\n                        return [4 /*yield*/, db_wrapper_1.default.getItemsInRange(this.name, tableIndexRange)];\n                    case 2: return [2 /*return*/, _a.sent()];\n                    case 3:\n                        e_3 = _a.sent();\n                        throw formatted_result_1.default['GET_IN_RANGE_FAIL'].setData({\n                            desc: \"\" + e_3\n                        });\n                    case 4: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    CustomDB.prototype.deleteItemsInRange = function (tableIndexRanges) {\n        return __awaiter(this, void 0, void 0, function () {\n            var e_4;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        try {\n                            utils_1.paramChecker(tableIndexRanges, utils_1.ParamCheckerEnum.Array, 'tableIndexRanges', !OPTIONAL);\n                            tableIndexRanges.forEach(function (tableIndexRange) {\n                                tableIndexRangeParamChecker(tableIndexRange);\n                            });\n                        }\n                        catch (errMsg) {\n                            throw formatted_result_1.default['PARAM_INVALID'].setData({\n                                desc: \"\" + errMsg\n                            });\n                        }\n                        _a.label = 1;\n                    case 1:\n                        _a.trys.push([1, 3, , 4]);\n                        return [4 /*yield*/, db_wrapper_1.default.deleteItems(this.name, tableIndexRanges)];\n                    case 2:\n                        _a.sent();\n                        return [2 /*return*/, formatted_result_1.default['SUCC']];\n                    case 3:\n                        e_4 = _a.sent();\n                        throw formatted_result_1.default['DELETE_ITEMS_FAIL'].setData({\n                            desc: \"\" + e_4\n                        });\n                    case 4: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    return CustomDB;\n}());\nexports.CustomDB = CustomDB;\nfunction deleteDB(dbName) {\n    return __awaiter(this, void 0, void 0, function () {\n        var e_5;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    try {\n                        utils_1.paramChecker(dbName, utils_1.ParamCheckerEnum.String, 'dbName', !OPTIONAL);\n                    }\n                    catch (errMsg) {\n                        throw formatted_result_1.default['PARAM_INVALID'].setData({\n                            desc: \"\" + errMsg\n                        });\n                    }\n                    _a.label = 1;\n                case 1:\n                    _a.trys.push([1, 3, , 4]);\n                    return [4 /*yield*/, db_wrapper_1.default.deleteDB(dbName)];\n                case 2:\n                    _a.sent();\n                    return [2 /*return*/, formatted_result_1.default['SUCC']];\n                case 3:\n                    e_5 = _a.sent();\n                    throw formatted_result_1.default['DELETE_DB_FAIL'].setData({\n                        desc: \"\" + e_5\n                    });\n                case 4: return [2 /*return*/];\n            }\n        });\n    });\n}\nexports.deleteDB = deleteDB;\nexports.default = {\n    idbIsSupported: idbIsSupported,\n    CustomDB: CustomDB,\n    deleteDB: deleteDB\n};\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @file IndexedDB compatibility checker\n */\nvar formatted_result_1 = require(\"./formatted_result\");\nexports.default = {\n    getResult: function () {\n        if (!window) {\n            return formatted_result_1.default['DB_NOT_SUPPORT'].setData({\n                desc: 'idb-managed can not run in non-browser environment'\n            });\n        }\n        try {\n            [\n                'indexedDB',\n                'IDBDatabase',\n                'IDBObjectStore',\n                'IDBTransaction',\n                'IDBIndex',\n                'IDBCursor',\n                'IDBKeyRange'\n            ].forEach(function (property) {\n                if (!window.hasOwnProperty(property)) {\n                    throw formatted_result_1.default['DB_NOT_SUPPORT'].setData({\n                        desc: property + \" is not supported in window\"\n                    });\n                }\n            });\n            return formatted_result_1.default['SUCC'];\n        }\n        catch (resultOb) {\n            return resultOb;\n        }\n    }\n};\n","\"use strict\";\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @file Provide unified formatted result for idb-managed\n */\nvar ResultFormatter = /** @class */ (function () {\n    function ResultFormatter(theCode, theMsg) {\n        this.code = theCode;\n        this.msg = theMsg;\n    }\n    ResultFormatter.prototype.setData = function (supplyment) {\n        this.data = __assign(__assign({}, this.data), supplyment);\n        return this;\n    };\n    ResultFormatter.prototype.toString = function () {\n        return \"FormattedResult{code: \" + this.code + \", msg: \" + this.msg + \", data: \" + JSON.stringify(this.data) + \"}\";\n    };\n    return ResultFormatter;\n}());\nexports.ResultFormatter = ResultFormatter;\nexports.default = {\n    get DB_NOT_SUPPORT() {\n        return new ResultFormatter(100, 'IndexedDB is not supported');\n    },\n    get PARAM_INVALID() {\n        return new ResultFormatter(101, 'Invalid parameter');\n    },\n    get SUCC() {\n        return new ResultFormatter(200, 'Successfully done');\n    },\n    get DB_NOT_FOUND() {\n        return new ResultFormatter(201, 'DB does not exist');\n    },\n    get TABLE_NOT_FOUND() {\n        return new ResultFormatter(202, 'Table does not exist');\n    },\n    get OPEN_DB_FAIL() {\n        return new ResultFormatter(203, 'Open DB failed');\n    },\n    get ADD_ITEMS_FAIL() {\n        return new ResultFormatter(204, 'Add items failed');\n    },\n    get GET_ITEM_FAIL() {\n        return new ResultFormatter(205, 'Get item failed');\n    },\n    get GET_IN_RANGE_FAIL() {\n        return new ResultFormatter(206, 'Get items in range failed');\n    },\n    get DELETE_ITEMS_FAIL() {\n        return new ResultFormatter(207, 'Delete items failed');\n    },\n    get DELETE_DB_FAIL() {\n        return new ResultFormatter(208, 'Delete DB failed');\n    },\n    get UNEXPECTED_ERR() {\n        return new ResultFormatter(666, 'Some unexpected error happens');\n    }\n};\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n;\nexports.ParamCheckerEnum = {\n    NonNegativeInteger: {\n        rule: isNonNegativeInteger,\n        desc: 'needs to be a non-negative integer'\n    },\n    NotNullObject: {\n        rule: function (param) {\n            return param && typeof param === 'object';\n        },\n        desc: 'needs to be a not-null object'\n    },\n    String: {\n        rule: function (param) {\n            return typeof param === 'string';\n        },\n        desc: 'needs to be a string'\n    },\n    Array: {\n        rule: function (param) {\n            return param instanceof Array;\n        },\n        desc: 'needs to be an Array'\n    },\n    Boolean: {\n        rule: function (param) {\n            return typeof param === 'boolean';\n        },\n        desc: 'needs to be a boolean'\n    }\n};\nfunction isNonNegativeInteger(x) {\n    return !isNaN(x) && x >= 0;\n}\nexports.isNonNegativeInteger = isNonNegativeInteger;\nfunction optionWithBackup(param, backup) {\n    return param !== undefined ? param : backup;\n}\nexports.optionWithBackup = optionWithBackup;\nfunction paramChecker(param, checker, paramName, optional) {\n    var exp = paramName + \" \" + checker.desc;\n    if (optional) {\n        if (param !== undefined && !checker.rule(param)) {\n            throw exp + \" if defined\";\n        }\n    }\n    else {\n        if (!checker.rule(param)) {\n            throw \"\" + exp;\n        }\n    }\n}\nexports.paramChecker = paramChecker;\nfunction deduplicateList(list) {\n    var deduplicatedList = list.reduce(function (accumulator, currentItem) {\n        if (accumulator.indexOf(currentItem) < 0) {\n            return accumulator.concat(currentItem);\n        }\n        else {\n            return accumulator;\n        }\n    }, []);\n    return deduplicatedList;\n}\nexports.deduplicateList = deduplicateList;\n"],"sourceRoot":""}